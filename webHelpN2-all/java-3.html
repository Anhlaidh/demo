<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2024-04-30T19:02:50.651939"><title>Java-3 | Notes</title><script type="application/json" id="virtual-toc-data">[{"id":"notes-java","level":0,"title":"notes.Java","anchor":"#notes-java"},{"id":"syntactic-sugar","level":0,"title":"语法糖 Syntactic sugar","anchor":"#syntactic-sugar"},{"id":"reflection","level":0,"title":"反射 reflection","anchor":"#reflection"},{"id":"api","level":0,"title":"编译器API","anchor":"#api"},{"id":"proxy","level":0,"title":"代理(Proxy):代替处理","anchor":"#proxy"},{"id":"aop-aspect-oriented-programming","level":0,"title":"AOP(Aspect Oriented Programming)","anchor":"#aop-aspect-oriented-programming"},{"id":"annotation","level":0,"title":"注解Annotation","anchor":"#annotation"},{"id":"nested-classes","level":0,"title":"嵌套类 Nested classes","anchor":"#nested-classes"},{"id":"lambda","level":0,"title":"Lambda表达式","anchor":"#lambda"},{"id":"stream","level":0,"title":"流 stream","anchor":"#stream"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b259/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Java-3 | Notes"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Notes Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/java-3.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Java-3 | Notes"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/java-3.html#webpage",
    "url": "writerside-documentation/java-3.html",
    "name": "Java-3 | Notes",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Notes Help"
}</script><!-- End Schema.org --></head><body data-id="Java-3" data-main-title="Java-3" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Notes///java///notes///Java"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Notes  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Java-3" id="Java-3.md">Java-3</h1><ul class="list _bullet" id="-i7x40f_8858"><li class="list__item" id="-i7x40f_8859"><p><span id="-i7x40f_8860">notes.Java</span></p><ul class="list _bullet" id="-i7x40f_8861"><li class="list__item" id="-i7x40f_8862"><p><span id="-i7x40f_8863">语法糖 Syntactic sugar</span></p><ul class="list _bullet" id="-i7x40f_8864"><li class="list__item" id="-i7x40f_8865"><p><span id="-i7x40f_8866">jdk版本</span></p></li><li class="list__item" id="-i7x40f_8867"><p><span id="-i7x40f_8868">for/for-each</span></p></li><li class="list__item" id="-i7x40f_8869"><p><span id="-i7x40f_8870">enum类型</span></p></li><li class="list__item" id="-i7x40f_8871"><p><span id="-i7x40f_8872">不定项参数</span></p></li><li class="list__item" id="-i7x40f_8873"><p><span id="-i7x40f_8874">静态导入</span></p></li><li class="list__item" id="-i7x40f_8875"><p><span id="-i7x40f_8876">自动装箱和拆箱</span></p></li><li class="list__item" id="-i7x40f_8877"><p><span id="-i7x40f_8878">多异常并列</span></p></li><li class="list__item" id="-i7x40f_8879"><p><span id="-i7x40f_8880">数字增强</span></p></li><li class="list__item" id="-i7x40f_8881"><p><span id="-i7x40f_8882">接口方法</span></p></li><li class="list__item" id="-i7x40f_8883"><p><span id="-i7x40f_8884">try-with-resource</span></p></li><li class="list__item" id="-i7x40f_8885"><p><span id="-i7x40f_8886">ResourceBundle文件加载</span></p></li><li class="list__item" id="-i7x40f_8887"><p><span id="-i7x40f_8888">var类型</span></p></li><li class="list__item" id="-i7x40f_8889"><p><span id="-i7x40f_8890">switch</span></p></li></ul></li><li class="list__item" id="-i7x40f_8891"><p><span id="-i7x40f_8892">反射 reflection</span></p></li><li class="list__item" id="-i7x40f_8893"><p><span id="-i7x40f_8894">编译器API</span></p><ul class="list _bullet" id="-i7x40f_8895"><li class="list__item" id="-i7x40f_8896"><p><span id="-i7x40f_8897">JavaCompiler</span></p></li></ul></li><li class="list__item" id="-i7x40f_8898"><p><span id="-i7x40f_8899">代理(Proxy):代替处理</span></p></li><li class="list__item" id="-i7x40f_8900"><p><span id="-i7x40f_8901">AOP(Aspect Oriented Programming)</span></p><ul class="list _bullet" id="-i7x40f_8902"><li class="list__item" id="-i7x40f_8903"><p><span id="-i7x40f_8904">面向切面编程</span></p></li></ul></li><li class="list__item" id="-i7x40f_8905"><p><span id="-i7x40f_8906">注解Annotation</span></p><ul class="list _bullet" id="-i7x40f_8907"><li class="list__item" id="-i7x40f_8908"><p><span id="-i7x40f_8909">自定义注解</span></p></li><li class="list__item" id="-i7x40f_8910"><p><span id="-i7x40f_8911">元注解</span></p></li></ul></li><li class="list__item" id="-i7x40f_8912"><p><span id="-i7x40f_8913">嵌套类 Nested classes</span></p></li><li class="list__item" id="-i7x40f_8914"><p><span id="-i7x40f_8915">Lambda表达式</span></p><ul class="list _bullet" id="-i7x40f_8916"><li class="list__item" id="-i7x40f_8917"><p><span id="-i7x40f_8918">函数式接口</span></p></li><li class="list__item" id="-i7x40f_8919"><p><span id="-i7x40f_8920">系统自带的函数式接口</span></p></li></ul></li></ul></li></ul><section class="chapter"><h2 id="notes-java" data-toc="notes-java">notes.Java</h2></section><section class="chapter"><h2 id="syntactic-sugar" data-toc="syntactic-sugar">语法糖 Syntactic sugar</h2><section class="chapter"><h3 id="jdk" data-toc="jdk">jdk版本</h3><ul class="list _bullet" id="-i7x40f_8921"><li class="list__item" id="-i7x40f_8922"><p>编译级别</p></li><li class="list__item" id="-i7x40f_8923"><p>兼容级别 </p><ul class="list _bullet" id="-i7x40f_8924"><li class="list__item" id="-i7x40f_8925"><p>编译后高版本可以运行低版本字节码</p></li><li class="list__item" id="-i7x40f_8926"><p>反之不行</p></li></ul></li></ul></section><section class="chapter"><h3 id="for-for-each" data-toc="for-for-each">for/for-each</h3><ul class="list _bullet" id="-i7x40f_8927"><li class="list__item" id="-i7x40f_8928"><p>for </p><ul class="list _bullet" id="-i7x40f_8929"><li class="list__item" id="-i7x40f_8930"><p><code class="code" id="-i7x40f_8931">for(int i=0;i&lt;nums.leng;i++)</code></p></li><li class="list__item" id="-i7x40f_8932"><p>可以删除元素</p></li></ul></li><li class="list__item" id="-i7x40f_8933"><p>for-each </p><ul class="list _bullet" id="-i7x40f_8934"><li class="list__item" id="-i7x40f_8935"><p><code class="code" id="-i7x40f_8936">for(String i:hs)</code></p></li><li class="list__item" id="-i7x40f_8937"><p>5.0开始存在</p></li><li class="list__item" id="-i7x40f_8938"><p>语法简洁</p></li><li class="list__item" id="-i7x40f_8939"><p>不能删除元素</p></li><li class="list__item" id="-i7x40f_8940"><p>只能正向遍历</p></li><li class="list__item" id="-i7x40f_8941"><p>不能同时遍历两个集合</p></li></ul></li></ul></section><section class="chapter"><h3 id="enum" data-toc="enum">enum类型</h3><ul class="list _bullet" id="-i7x40f_8942"><li class="list__item" id="-i7x40f_8943"><p>java5 推出</p></li><li class="list__item" id="-i7x40f_8944"><p>enum有多少个值就有几个实例对象</p></li><li class="list__item" id="-i7x40f_8945"><p>可以添加属性/构造函数/方法</p></li><li class="list__item" id="-i7x40f_8946"><p>构造函数只能是package-private(default)或者private,内部调用 enum类型 </p><ul class="list _bullet" id="-i7x40f_8947"><li class="list__item" id="-i7x40f_8948"><p>所有enum类型都是Enum的子类,也继承了相应方法</p></li><li class="list__item" id="-i7x40f_8949"><p>ordinal()返回枚举所在的索引位置,从0开始</p></li><li class="list__item" id="-i7x40f_8950"><p>compareTo()比较两个枚举值的索引位置大小</p></li><li class="list__item" id="-i7x40f_8951"><p>toString()返回枚举值的字符串标识</p></li><li class="list__item" id="-i7x40f_8952"><p>valueOf()将字符串初始化为枚举对象</p></li><li class="list__item" id="-i7x40f_8953"><p>values() 返回所有的枚举值</p></li></ul></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.suger;

/**
 * @Description:
 * @author: Anhlaidh
 * @date: 2020-07-05 21:31
 */
public class testEnum {
    public static void main(String[] args) {
        Fruit a1 = Fruit.APPLE;
        System.out.println(&quot;Price is&quot; + a1.price);

        System.out.println(&quot;====================&quot;);
        Day d1 = Day.MONDAY;
        Day d2 = Enum.valueOf(Day.class, &quot;MONDAY&quot;);
        System.out.println(d1 == d2);
        Day d3 = Enum.valueOf(Day.class, &quot;TUESDAY&quot;);
        System.out.println(d1.compareTo(d3));

        //遍历
        for (Day item : Day.values()) {
            //输出索引值
            System.out.println(item.toString() + &quot;,&quot; + item.ordinal());
        }
    }

    enum Day {
        MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
    }

    enum Fruit {
        APPLE(10), ORANGE(8);
        private int price;

        Fruit(int price) {
            this.price = price;
        }

        public int getPrice() {
            return price;
        }
    }


}

</div></section><section class="chapter"><h3 id="-i7x40f_8955" data-toc="-i7x40f_8955">不定项参数</h3><ul class="list _bullet" id="-i7x40f_8956"><li class="list__item" id="-i7x40f_8957"><p>JDK5提供了不定参数(可变参数)功能 </p><ul class="list _bullet" id="-i7x40f_8958"><li class="list__item" id="-i7x40f_8959"><p>类型后面加3个点,入int.../double.../String...</p></li><li class="list__item" id="-i7x40f_8960"><p>可变参数,本质上是一个数组</p></li><li class="list__item" id="-i7x40f_8961"><p>一个方法只能由一个不定项参数,且位于参数列表的最后</p></li><li class="list__item" id="-i7x40f_8962"><p>重载的优先级规则1:固定参数的方法,比可变参数优先级更高</p></li><li class="list__item" id="-i7x40f_8963"><p>重载的优先级规则2:调用语句,同时与两个带可变参数的方法匹配,则报错</p></li></ul></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.suger;

/**
 * @Description: 可变参数
 * @author: Anhlaidh
 * @date: 2020-07-05 21:46
 */
public class testVariableArgument {
    public static void main(String[] args) {
        print();
        print(&quot;aaa&quot;);
        print(&quot;aaa&quot;,&quot;bbb&quot;);
        print(&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;);

    }

    private static void print(String... args) {
        System.out.println(args.length);
        for (String arg : args) {
            System.out.println(arg);
        }
    }

    //当只有一个参数时,本方法优先级更高
    private static void print(String s) {
        System.out.println(&quot;优先级高的方法&quot;);
    }

    //错误:一个方法不可以有多个可变参数
//    public static void print(String... args, int... irgs) {
//
//    }
    //调用语句,同时与两个带可变参数的方法匹配,则报错
//    private static void print(String s1, String... args) {
//
//    }
}

</div></section><section class="chapter"><h3 id="-i7x40f_8965" data-toc="-i7x40f_8965">静态导入</h3><ul class="list _bullet" id="-i7x40f_8966"><li class="list__item" id="-i7x40f_8967"><p>import static</p></li><li class="list__item" id="-i7x40f_8968"><p>导入类中的静态方法 </p><ul class="list _bullet" id="-i7x40f_8969"><li class="list__item" id="-i7x40f_8970"><p>使用时可以直接写方法名,不写类名</p></li></ul></li><li class="list__item" id="-i7x40f_8971"><p>少用*</p></li><li class="list__item" id="-i7x40f_8972"><p>如果重名需要补充类名</p></li></ul></section><section class="chapter"><h3 id="-i7x40f_8973" data-toc="-i7x40f_8973">自动装箱和拆箱</h3><ul class="list _bullet" id="-i7x40f_8974"><li class="list__item" id="-i7x40f_8975"><p>JDK5开始引入,简化基本类型和对象转化的写法</p></li><li class="list__item" id="-i7x40f_8976"><p>Integer--int...</p></li><li class="list__item" id="-i7x40f_8977"><p>编译器的工作,不是jvm的工作</p></li><li class="list__item" id="-i7x40f_8978"><p><code class="code" id="-i7x40f_8979">==</code> :基本类型是内容相同,对象是指针是否相同</p></li><li class="list__item" id="-i7x40f_8980"><p>基本类型没有空值,对象有null</p></li><li class="list__item" id="-i7x40f_8981"><p>基础数据类型与封装类型进行 <code class="code" id="-i7x40f_8982">==</code>, <code class="code" id="-i7x40f_8983">+</code>, <code class="code" id="-i7x40f_8984">-</code>, <code class="code" id="-i7x40f_8985">*</code>, <code class="code" id="-i7x40f_8986">/</code>操作运算,会将封装类进行拆箱,对基础数据类型进行运算</p></li><li class="list__item" id="-i7x40f_8987"><p>谨慎使用多个非同类的数值类进行运算</p></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.suger;

/**
 * @Description:
 * @author: Anhlaidh
 * @date: 2020-07-07 15:31
 */
public class testNumber {
    public static void main(String[] args) {
        Integer a1 = 1000;
        int a2 = 1000;
        Integer a3 = 2000;
        Long a4 = 2000L;
        long a5 = 2000L;
        System.out.println(a1 == a2);//拆箱再进行数值比较
        System.out.println(a3 == (a1 + a2));//拆箱再进行数值比较
        System.out.println(a4 == (a1 + a2));//拆箱再进行数值比较
        System.out.println(a5 == (a1 + a2));//拆箱再进行数值比较

        System.out.println(a3.equals(a1 + a2));//equals要求同类且内容相同
        System.out.println(a4.equals(a1 + a2));//equals要求同类且内容相同
        System.out.println(a4.equals((long)(a1 + a2)));//equals要求同类,且值相同
//        System.out.println(a3 == a4);//不同类型不能比较
    }
}

</div></section><section class="chapter"><h3 id="-i7x40f_8989" data-toc="-i7x40f_8989">多异常并列</h3><ul class="list _bullet" id="-i7x40f_8990"><li class="list__item" id="-i7x40f_8991"><p>多个异常用 <code class="code" id="-i7x40f_8992">|</code> 隔开</p></li><li class="list__item" id="-i7x40f_8993"><p>多个异常之间不能有直接/简介继承关系</p></li></ul></section><section class="chapter"><h3 id="-i7x40f_8994" data-toc="-i7x40f_8994">数字增强</h3><ul class="list _bullet" id="-i7x40f_8995"><li class="list__item" id="-i7x40f_8996"><p>数字可以二进制赋值 </p><ul class="list _bullet" id="-i7x40f_8997"><li class="list__item" id="-i7x40f_8998"><p>避免二进制计算</p></li><li class="list__item" id="-i7x40f_8999"><p>byte/short/int/long</p></li></ul></li><li class="list__item" id="-i7x40f_9000"><p>数值字面量中可以使用下划线 </p><ul class="list _bullet" id="-i7x40f_9001"><li class="list__item" id="-i7x40f_9002"><p>增加数字的可读性和纠错功能</p></li><li class="list__item" id="-i7x40f_9003"><p>short/int/long/float/double</p></li><li class="list__item" id="-i7x40f_9004"><p>下划线只能出现在数字中间</p></li></ul></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.suger;

/**
 * @Description:
 * @author: Anhlaidh
 * @date: 2020-07-07 15:40
 */
public class testNumber2 {
    public static void main(String[] args) {
        test1();
        test2();

    }

    private static void test2() {
        long a1 = 9999999999L;
        long a2 = 9_999_999_999L;
        int a3 = 0b0111_1011_0001;//二进制0b开头
        int a4 = 02_014;//8进制,0开头
        int a5 = 123__45;//可以多个下划线
        int a6 = 0x7_B_1;//十六进制
        float a7 = 3.56_78f;//float
        double a8 = 1.3_45_67;//double

//        int b1 = 0b_123_4; _必须在数字之间
//        int b2 = 0123_4_;不能在末尾
//        int b3 = _123;不能在开头
//        int b4 = 0_ x_123;不能拆开0x
//        int b5 = 0x_51;_必须在数字之间
//        long b6 = 1000_L;_必须在数字之间
//        float b7 = 1.34f _;_不能在末尾
        
    }

    private static void test1() {
        byte a1 = (byte) 0b00100001;
        short a2 = (short) 0b001010100;
        int a3 = 0b0010101010;
        int a4 = 0b101;
        int a5 = 0B101;//B可以大小写
        long a6 = 0b1010101010010010010101010L;
        final int[] s1 = {0b101010, 0b101101, 0b1101111, 0b1111};
        System.out.println(a5);
        System.out.println(Integer.toBinaryString(a5));
    }
    
}

</div></section><section class="chapter"><h3 id="-i7x40f_9006" data-toc="-i7x40f_9006">接口方法</h3><ul class="list _bullet" id="-i7x40f_9007"><li class="list__item" id="-i7x40f_9008"><p id="-i7x40f_9009">java8 接口默认方法/静态方法(都带具体实现)</p></li><li class="list__item" id="-i7x40f_9010"><p id="-i7x40f_9011">默认方法</p><ul class="list _bullet" id="-i7x40f_9012"><li class="list__item" id="-i7x40f_9013"><p>规则 </p><ul class="list _bullet" id="-i7x40f_9014"><li class="list__item" id="-i7x40f_9015"><p>以default关键字标注,其他定义和普通函数一样</p></li><li class="list__item" id="-i7x40f_9016"><p>规则1:默认方法 不能重写 Object中的方法</p></li><li class="list__item" id="-i7x40f_9017"><p>规则2:实现类可以继承/重写父接口默认方法</p></li><li class="list__item" id="-i7x40f_9018"><p>规则3:接口可以继承/重写父接口的默认方法</p></li><li class="list__item" id="-i7x40f_9019"><p>规则4:当父类和父接口都有(同名同参数) 默认方法,子类继承父类的默认方法,这样可以兼容JDK7及以前的代码</p></li><li class="list__item" id="-i7x40f_9020"><p>规则5:子类实现了两个接口(均有同名同参数的默认方法),那么编译失败,必须在子类中重写这个default方法</p></li></ul></li></ul></li><li class="list__item" id="-i7x40f_9021"><p id="-i7x40f_9022">静态方法</p><ul class="list _bullet" id="-i7x40f_9023"><li class="list__item" id="-i7x40f_9024"><p>属于本接口,不属于子类/子接口</p></li><li class="list__item" id="-i7x40f_9025"><p>子类(子接口)没有继承该静态方法,只能通过所在的接口名来调用 -java9 私有方法</p></li><li class="list__item" id="-i7x40f_9026"><p>解决多个默认方法/静态方法的内容重复问题</p></li><li class="list__item" id="-i7x40f_9027"><p>私有方法属于本接口,只在本接口内使用,不属于子类/子接口</p></li><li class="list__item" id="-i7x40f_9028"><p>子类(子接口)没有继承该私有方法,也无法调用</p></li><li class="list__item" id="-i7x40f_9029"><p>静态私有方法可以被静态/默认方法调用,非静态私有方法被默认方法调用</p></li></ul></li><li class="list__item" id="-i7x40f_9030"><p id="-i7x40f_9031">接口,抽象类</p><ul class="list _bullet" id="-i7x40f_9032"><li class="list__item" id="-i7x40f_9033"><p>相同点 </p><ul class="list _bullet" id="-i7x40f_9034"><li class="list__item" id="-i7x40f_9035"><p>都是抽象的,都不能被实例化,即不能被new</p></li><li class="list__item" id="-i7x40f_9036"><p>都可以有实现方法</p></li><li class="list__item" id="-i7x40f_9037"><p>都可以不需要继承者实现所有方法</p></li></ul></li><li class="list__item" id="-i7x40f_9038"><p>不同点(java12之前) </p><ul class="list _bullet" id="-i7x40f_9039"><li class="list__item" id="-i7x40f_9040"><p>抽象类最多只能继承一个,接口可以实现多个</p></li><li class="list__item" id="-i7x40f_9041"><p>接口的变量默认是public static final,且必须有初值,子类不能修改,而抽象类的变量默认是default,子类可以继承修改</p></li><li class="list__item" id="-i7x40f_9042"><p>接口没有构造函数,抽象类有构造函数</p></li><li class="list__item" id="-i7x40f_9043"><p>接口没有main函数,抽象类可以有main函数</p></li><li class="list__item" id="-i7x40f_9044"><p>接口有public/default/private的方法,抽象类只有public/private/protected/不写关键字的(default)的方法</p></li></ul></li></ul></li></ul></section><section class="chapter"><h3 id="try-with-resource" data-toc="try-with-resource">try-with-resource</h3><ul class="list _bullet" id="-i7x40f_9045"><li class="list__item" id="-i7x40f_9046"><p>jdk7提供try-with-resource </p><ul class="list _bullet" id="-i7x40f_9047"><li class="list__item" id="-i7x40f_9048"><p>资源要求定义在try中,若已经定义在外面,则需要一个本地变量</p></li></ul></li><li class="list__item" id="-i7x40f_9049"><p>jdk9不在要求定义临时变量,可以直接使用外部资源变量</p></li><li class="list__item" id="-i7x40f_9050"><p>原理 </p><ul class="list _bullet" id="-i7x40f_9051"><li class="list__item" id="-i7x40f_9052"><p>资源对象必须实现AutoCloseable接口,即close方法,jdk自带</p></li></ul></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.suger.testTryWithResource;

/**
 * @Description:
 * @author: Anhlaidh
 * @date: 2020-07-07 16:58
 */
public class test {
    public static void main(String[] args) {
        try (MyConnection connection = new MyConnection()) {
            connection.sendData();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
class MyConnection implements AutoCloseable {
    public void sendData() throws Exception {
        System.out.println(&quot;Send Data...&quot;);
    }
    @Override
    public void close() throws Exception {
        System.out.println(&quot;Close...&quot;);
    }
}
</div></section><section class="chapter"><h3 id="resourcebundle" data-toc="resourcebundle">ResourceBundle文件加载</h3><ul class="list _bullet" id="-i7x40f_9054"><li class="list__item" id="-i7x40f_9055"><p>JDK9及以后,ResourceBundle默认以UTF-8方式加载</p></li></ul></section><section class="chapter"><h3 id="var" data-toc="var">var类型</h3><ul class="list _bullet" id="-i7x40f_9056"><li class="list__item" id="-i7x40f_9057"><p>java10推出var </p><ul class="list _bullet" id="-i7x40f_9058"><li class="list__item" id="-i7x40f_9059"><p>避免信息冗余</p></li><li class="list__item" id="-i7x40f_9060"><p>对齐了变量名</p></li><li class="list__item" id="-i7x40f_9061"><p>更容易阅读</p></li><li class="list__item" id="-i7x40f_9062"><p>本质上还是强类型语言,编译器负责推断类型,并写入字节码文件,因此推断后不能更改</p></li></ul></li><li class="list__item" id="-i7x40f_9063"><p>var的限制 </p><ul class="list _bullet" id="-i7x40f_9064"><li class="list__item" id="-i7x40f_9065"><p>可以用在局部变量中,非类成员变量</p></li><li class="list__item" id="-i7x40f_9066"><p>可以在for/for-each中</p></li><li class="list__item" id="-i7x40f_9067"><p>声明时必须初始化</p></li><li class="list__item" id="-i7x40f_9068"><p>不能用在方法(形式)参数和返回类型</p></li><li class="list__item" id="-i7x40f_9069"><p>大面积滥用会使代码整体阅读性变差</p></li><li class="list__item" id="-i7x40f_9070"><p>var 只在编译时起作用,没有在字节码中引入新的内容,也没有专门的jvm指令处理var</p></li></ul></li></ul></section><section class="chapter"><h3 id="switch" data-toc="switch">switch</h3><ul class="list _bullet" id="-i7x40f_9071"><li class="list__item" id="-i7x40f_9072"><p>支持的类型:byte/Byte,short/Short,int/Integer,char/Character,String(7.0),Enum(5.0)</p></li><li class="list__item" id="-i7x40f_9073"><p>仍不支持long/float/double</p></li><li class="list__item" id="-i7x40f_9074"><p>多分支合并</p></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.suger;

import java.util.Scanner;

/**
 * @Description:
 * @author: Anhlaidh
 * @date: 2020-07-07 17:16
 */
public class testSwitch {
    public static void main(String[] args) {
//        test1();
        test2();
    }

    private static void test2() {
        Scanner scanner = new Scanner(System.in);
        int num= scanner.nextInt();
        int days = switch (num){
            case 1,3,5,7,8,10,12 -&gt; 31;
            case 4,6,9,11 -&gt; 30;
            default -&gt; 28;
        };
        System.out.println(days);
    }

    private static void test1() {
        Scanner scanner = new Scanner(System.in);
        String month = scanner.next();
        int result=-1;
        switch (month) {
            case &quot;Jan&quot;,&quot;Mar&quot;,&quot;May&quot;,&quot;July&quot;,&quot;Aug&quot;,&quot;Oct&quot;,&quot;Dec&quot; -&gt; result = 31;
            case &quot;Apr&quot;,&quot;June&quot;,&quot;Sep&quot;,&quot;Nov&quot; -&gt; result = 30;
            case &quot;Feb&quot; -&gt; result = 28;
            default -&gt; result = -1;


        }
        System.out.println(result);
    }
}


</div></section></section><section class="chapter"><h2 id="reflection" data-toc="reflection">反射 reflection</h2><ul class="list _bullet" id="-i7x40f_9076"><li class="list__item" id="-i7x40f_9077"><p>定义 </p><ul class="list _bullet" id="-i7x40f_9078"><li class="list__item" id="-i7x40f_9079"><p>程序可以访问,检测和修改它本身状态或行为的能力,即自描述和自控制</p></li><li class="list__item" id="-i7x40f_9080"><p>可以在运行时加载,探知,和使用编译期间完全未知的类</p></li><li class="list__item" id="-i7x40f_9081"><p>给java插上动态语言特性的翅膀,弥补强类型语言的不足</p></li><li class="list__item" id="-i7x40f_9082"><p>java.lan.reflect包,在java2存在,java5完善</p></li></ul></li><li class="list__item" id="-i7x40f_9083"><p>功能 </p><ul class="list _bullet" id="-i7x40f_9084"><li class="list__item" id="-i7x40f_9085"><p>在运行中分析类的能力</p></li><li class="list__item" id="-i7x40f_9086"><p>在运行中查看和操作对象 </p><ul class="list _bullet" id="-i7x40f_9087"><li class="list__item" id="-i7x40f_9088"><p>基于反射自由创建对象</p></li><li class="list__item" id="-i7x40f_9089"><p>反射构建出无法直接访问的类</p></li><li class="list__item" id="-i7x40f_9090"><p>set或者get到无法访问的成员变量</p></li><li class="list__item" id="-i7x40f_9091"><p>调用不可访问的方法</p></li></ul></li><li class="list__item" id="-i7x40f_9092"><p>实现通用的数组操作代码</p></li><li class="list__item" id="-i7x40f_9093"><p>类似函数指针的功能</p></li></ul></li><li class="list__item" id="-i7x40f_9094"><p>创建对象 </p><ol class="list _decimal" id="-i7x40f_9095" type="1"><li class="list__item" id="-i7x40f_9096"><p id="-i7x40f_9097">静态编码&amp;编译(new)</p></li><li class="list__item" id="-i7x40f_9098"><p id="-i7x40f_9099">克隆(clone()),继承Cloneable,速度快</p></li><li class="list__item" id="-i7x40f_9100"><p id="-i7x40f_9101">序列化serialization,反序列化deserialization继承Serializable接口</p><ul class="list _bullet" id="-i7x40f_9102"><li class="list__item" id="-i7x40f_9103"><div class="code-block" data-lang="java">
  package notes.Java.Java_Final.Reflect;

  import java.io.*;

  /**
   * @Description:
   * @author: Anhlaidh
   * @date: 2020-07-07 18:05
   */
  public class testSerialization {
      public static void main(String[] args) throws IOException, ClassNotFoundException {
          A obj1 = new A();
          ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;data.obj&quot;));
          out.writeObject(obj1);
          out.close();
          ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;data.obj&quot;));
          A obj2 = (A) in.readObject();
          in.close();
          obj2.hello();
      }

  }

  class A implements Serializable {
      private static final long serialVersionUID = 1L;

      public void hello() {
          System.out.println(&quot;hello from A&quot;);

      }

  }
</div></li></ul></li><li class="list__item" id="-i7x40f_9105"><p id="-i7x40f_9106">反射</p><div class="code-block" data-lang="java">
package notes.Java.Java_Final.Reflect;


import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

/**
 * @Description:
 * @author: Anhlaidh
 * @date: 2020-07-07 19:32
 */
public class testNewInstance {
    public static void main(String[] args) throws ClassNotFoundException, InvocationTargetException, IllegalAccessException, InstantiationException, NoSuchMethodException {
        Object obj1 = Class.forName(&quot;notes.Java.Java_Final.Reflect.A&quot;).newInstance();
        Method m = Class.forName(&quot;notes.Java.Java_Final.Reflect.A&quot;).getMethod(&quot;hello&quot;);
        m.invoke(obj1);//获取方法
        A obj2 = (A) Class.forName(&quot;notes.Java.Java_Final.Reflect.A&quot;).newInstance();
        Constructor&lt;A&gt; constructor = A.class.getConstructor();//构造函数
        A obj3 = constructor.newInstance();
        obj3.hello();

    }

}

</div></li></ol></li><li class="list__item" id="-i7x40f_9108"><p>内容 </p><ol class="list _decimal" id="-i7x40f_9109" type="1"><li class="list__item" id="-i7x40f_9110"><p>Class:类型标识 </p><ul class="list _bullet" id="-i7x40f_9111"><li class="list__item" id="-i7x40f_9112"><p>JVM为每个对象都保留其类型标识信息(Runtime Type Identification)</p></li><li class="list__item" id="-i7x40f_9113"><p>成员变量,方法,构造函数,修饰符,包,父类,父接口...</p></li><li class="list__item" id="-i7x40f_9114"><p>成员变量Field</p></li><li class="list__item" id="-i7x40f_9115"><p>方法Method</p></li><li class="list__item" id="-i7x40f_9116"><p>构造函数Constructor</p></li></ul></li></ol></li></ul></section><section class="chapter"><h2 id="api" data-toc="api">编译器API</h2><ul class="list _bullet" id="-i7x40f_9117"><li class="list__item" id="-i7x40f_9118"><p>对 .java文件即时编译</p></li><li class="list__item" id="-i7x40f_9119"><p>对字符串即时编译</p></li><li class="list__item" id="-i7x40f_9120"><p>监听在编译过程中产生的警告和错误</p></li><li class="list__item" id="-i7x40f_9121"><p>在代码中运行编译器(并非:Runtime命令调用javac命令)</p></li></ul><section class="chapter"><h3 id="javacompiler" data-toc="javacompiler">JavaCompiler</h3><ul class="list _bullet" id="-i7x40f_9122"><li class="list__item" id="-i7x40f_9123"><p id="-i7x40f_9124">1.6推出</p></li><li class="list__item" id="-i7x40f_9125"><p id="-i7x40f_9126">可用在程序文件中的Java编译器接口(代替javac.exe)</p></li><li class="list__item" id="-i7x40f_9127"><p id="-i7x40f_9128">在程序中编译java文件,产生class文件</p></li><li class="list__item" id="-i7x40f_9129"><p id="-i7x40f_9130">run方法(继承自java.tools.Tools):较简单,可以编译java源文件,生成class文件,但不能指定输出 路径,监控错误信息,调用后就在源码所在目录生成class文件</p></li><li class="list__item" id="-i7x40f_9131"><p id="-i7x40f_9132">getTask方法:更强大的功能,可以编译java源文件,包括在内存中的java文件(字符串),生成class文件</p></li><li class="list__item" id="-i7x40f_9133"><p id="-i7x40f_9134">编译文件:</p></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.JavaCompiler;

import javax.tools.JavaCompiler;
import javax.tools.ToolProvider;
import java.io.ByteArrayOutputStream;
import java.nio.charset.Charset;

/**
 * @Description:
 * @author: Anhlaidh
 * @date: 2020-08-04 14:30
 */
public class SimpleJavaCompiler {
    public static void main(String[] args) {
//        successCompile();

        failCompile();
    }

    private static void failCompile() {
        ByteArrayOutputStream err = new ByteArrayOutputStream();
        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        int result = compiler.run(null, null, err, &quot;./aaa.java&quot;);
        if (0 == result) {
            System.out.println(&quot;Success&quot;);
        } else {
            System.out.println(&quot;Fail&quot;);
            System.out.println(new String(err.toByteArray(), Charset.defaultCharset()) );
        }
    }


    private static void successCompile() {
        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        /**
         * 第一个参数:输入流,null表示默认使用system.in
         * 第二个参数:输出流,null标识默认使用system.out
         * 第三个参数:错误流,null标识默认使用system.err
         * 第四个参数:String...需要编译的文件名
         * 返回值:0表示成功,其他错误
         */
        int result = compiler.run(null, null, null, &quot;G:\\Coding\\src\\main\\java\\notes.Java\\Java_Final\\API\\hello1.java&quot;,&quot;G:\\Coding\\src\\main\\java\\notes.Java\\Java_Final\\API\\hello2.java&quot;);

        System.out.println(0 == result ? &quot;Success&quot; : &quot;Fail&quot;);
    }
}

</div><ul class="list _bullet" id="-i7x40f_9136"><li class="list__item" id="-i7x40f_9137"><p>编译字符串</p></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.JavaCompiler;

import javax.tools.*;
import java.io.File;
import java.lang.reflect.Method;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.charset.Charset;
import java.util.Arrays;

/**
 * @Description:
 * @author: Anhlaidh
 * @date: 2020-08-04 14:46
 */
public class JavaCompilerTask {
    public static void main(String[] args) {
        compilerJavaFromString();
//        System.out.println(&quot;hello world&quot;);
    }

    private static void compilerJavaFromString() {
        StringBuffer stringBuffer = new StringBuffer();
        String className = &quot;Hello&quot;;
        stringBuffer.append(&quot;public class &quot; + className + &quot;{&quot;);
        stringBuffer.append(&quot; public static void main(String[] args) {&quot;);
        stringBuffer.append(&quot; System.out.println(\&quot;hello world\&quot;);\n&quot;);
        stringBuffer.append(&quot;}\n&quot;);
        stringBuffer.append(&quot;}\n&quot;);


        Class&lt;?&gt; c = compiler(className, stringBuffer.toString());
        try {
            //生成对象
            Object obj = c.newInstance();
            Method m = c.getMethod(&quot;main&quot;, String[].class);
            m.invoke(obj, new Object[]{new String[]{}});

        } catch (Exception e) {
            e.printStackTrace();

        }

    }

    private static Class&lt;?&gt; compiler(String className, String javaCode) {
        JavaSourceFromString srcObject = new JavaSourceFromString(className, javaCode);
        System.out.println(srcObject.getCode());
        Iterable&lt;? extends JavaFileObject&gt; fileObjects = Arrays.asList(srcObject);

        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, null, Charset.defaultCharset());
        DiagnosticCollector&lt;JavaFileObject&gt; diagnosticCollector = new DiagnosticCollector&lt;&gt;();
        //设置编译的输出目录,并包装在options中
        String flag = &quot;-d&quot;;
        String outDir = &quot;&quot;;
        try {
            URL resource = Thread.currentThread().getContextClassLoader().getResource(&quot;&quot;);
            File classpath = new File(resource.toURI());
            outDir = classpath.getAbsolutePath() + File.separator;
            System.out.println(outDir);
        } catch (URISyntaxException e) {
            e.printStackTrace();
        }
        Iterable&lt;String&gt; options = Arrays.asList(flag, outDir);
        /**
         * JavaCompiler.getTask方法:以future的任务形式(多线程)来执行编译任务
         * 第一个参数:额外输出流,null表示默认使用System.err
         * 第二个参数:文件管理器,null表示编译器默认方法来报告诊断信息
         * 第三个参数:诊断监听器,null表示使用编译器默认方法来报告诊断信息
         * 第四个参数:编译器参数,null表示无参数
         * 第五个参数:需要经过annotation处理的类名,null表示没有类需要annotation
         * 第六个参数,待编译的类
         */
        JavaCompiler.CompilationTask task = compiler.getTask(null, fileManager, diagnosticCollector, options, null, fileObjects);
        //等待编译结束
        boolean result = task.call();
        if (result == true) {

            try {
                return Class.forName(className);
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            }
        } else {
            for (Diagnostic diagnostic : diagnosticCollector.getDiagnostics()) {
                System.out.println(&quot;Error on line:&quot; + diagnostic.getLineNumber() + &quot;;URI&quot; + diagnostic.getSource().toString());
            }

        }
        return null;
    }

}

</div><ul class="list _bullet" id="-i7x40f_9139"><li class="list__item" id="-i7x40f_9140"><p>其中的JavaSourceFromString 类</p></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.JavaCompiler;

import javax.tools.SimpleJavaFileObject;
import java.io.IOException;
import java.net.URI;

/**
 * @Description: A file object used to represent source coming from a string
 * @author: Anhlaidh
 * @date: 2020-08-04 14:57
 */
public class JavaSourceFromString extends SimpleJavaFileObject {
    private String code;
    public JavaSourceFromString(String name, String code) {
        super(URI.create(&quot;string:///&quot; + name.replace('.', '/') + Kind.SOURCE.extension),Kind.SOURCE);
        this.code = code;
    }

    @Override
    public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {
        return code;
    }

    public String getCode() {
        return code;
    }
}

</div><ul class="list _bullet" id="-i7x40f_9142"><li class="list__item" id="-i7x40f_9143"><p>notes.Java EE 的Jsp编译</p></li><li class="list__item" id="-i7x40f_9144"><p>在线编程观景</p></li><li class="list__item" id="-i7x40f_9145"><p>在线程序评判系统(OJ)</p></li><li class="list__item" id="-i7x40f_9146"><p>自动化的构建和测试工具</p></li></ul></section></section><section class="chapter"><h2 id="proxy" data-toc="proxy">代理(Proxy):代替处理</h2><ul class="list _bullet" id="-i7x40f_9147"><li class="list__item" id="-i7x40f_9148"><p>代理模式 </p><ul class="list _bullet" id="-i7x40f_9149"><li class="list__item" id="-i7x40f_9150"><p>外界不用直接访问目标对象,而是访问代理对象,由代理对象再调用目标对象</p></li><li class="list__item" id="-i7x40f_9151"><p>代理对象中可以添加监控和审查处理</p></li><li class="list__item" id="-i7x40f_9152"><p>静态代理 </p><ul class="list _bullet" id="-i7x40f_9153"><li class="list__item" id="-i7x40f_9154"><p>代理对象持有目标对象的句柄</p></li><li class="list__item" id="-i7x40f_9155"><p>所有调用目标对象的方法,都调用代理对象的方法</p></li><li class="list__item" id="-i7x40f_9156"><p>对每个方法,需要静态编码(理解简单,但代码繁琐)</p></li></ul></li><li class="list__item" id="-i7x40f_9157"><p>动态代理 </p><ul class="list _bullet" id="-i7x40f_9158"><li class="list__item" id="-i7x40f_9159"><p>对目标对象的方法每次被调用,进行动态拦截</p></li><li class="list__item" id="-i7x40f_9160"><p>方法重名会用第一个接口的方法</p></li></ul></li></ul></li><li class="list__item" id="-i7x40f_9161"><p>Main</p></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.Proxy.test;

import java.lang.reflect.*;
import java.util.Arrays;

/**
 * @Description:
 * @author: Anhlaidh
 * @date: 2020-08-04 18:06
 */
public class MultipleInterfacesProxyTest {
    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        Cook cook = new CookImpl();
        ClassLoader cl = MultipleInterfacesProxyTest.class.getClassLoader();
        ProxyHandler handler = new ProxyHandler(cook);
        //生成代理类型
        Class&lt;?&gt; proxyClass = Proxy.getProxyClass(cl, new Class&lt;?&gt;[]{Cook.class, Driver.class});
        //生成代理对象
        Object proxy = proxyClass.getConstructor(new Class[]{InvocationHandler.class}).newInstance(new Object[]{handler});
        System.out.println(Proxy.isProxyClass(proxyClass));

        Proxy p = (Proxy) proxy;
        System.out.println(Proxy.getInvocationHandler(proxy).getClass().getName());
        System.out.println(&quot;proxy类型&quot; + proxyClass.getName());
        //代理对象都继承于java.lang.reflect.Proxy,但是获取父类是Object而不是Proxy
        Class father = proxyClass.getSuperclass();
        System.out.println(&quot;proxy的父类类型:&quot; + father.getName());
        Class[] cs = proxy.getClass().getInterfaces();
        for (Class c : cs) {

            System.out.println(&quot;proxy的父接口类型&quot; + c.getName());
        }
        System.out.println(&quot;===============&quot;);
        Method[] ms = proxy.getClass().getMethods();
        for (Method m : ms) {
            System.out.println(&quot;调用方法&quot; + m.getName() + &quot;参数为&quot; + Arrays.deepToString(m.getParameters()));
        }
        System.out.println(&quot;===============&quot;);
        Cook c = (Cook) proxy;
        c.doWork();
        Driver d = (Driver) proxy;
        d.doWork();

    }
}

</div><ul class="list _bullet" id="-i7x40f_9163"><li class="list__item" id="-i7x40f_9164"><p>Handler</p></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.Proxy.test;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.util.Arrays;

/**
 * @Description:
 * @author: Anhlaidh
 * @date: 2020-08-04 18:03
 */
public class ProxyHandler implements InvocationHandler {
    private Cook cook;

    public ProxyHandler(Cook cook) {
        this.cook = cook;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;proxy类型&quot; + proxy.getClass().getName());
        System.out.println(&quot;调用方法&quot; + method + &quot;;参数为&quot; + Arrays.deepToString(args));
        Object result = method.invoke(cook, args);
        return result;
    }
}

</div></section><section class="chapter"><h2 id="aop-aspect-oriented-programming" data-toc="aop-aspect-oriented-programming">AOP(Aspect Oriented Programming)</h2><ul class="list _bullet" id="-i7x40f_9166"><li class="list__item" id="-i7x40f_9167"><p>面向对象: 将需求功能划分为不同的,独立,分装良好的类,并让他们通过继承和多态实现相同和不同行为</p></li><li class="list__item" id="-i7x40f_9168"><p>面向切面: 将通用需求功能从众多类中分离出来,使得很多类共享一个行为,一旦发生变化,不必修改很多类,而只修改这个行为即可</p></li></ul><section class="chapter"><h3 id="-i7x40f_9169" data-toc="-i7x40f_9169">面向切面编程</h3><ul class="list _bullet" id="-i7x40f_9170"><li class="list__item" id="-i7x40f_9171"><p>一个概念/规范,没有限定语言</p></li><li class="list__item" id="-i7x40f_9172"><p>不是取代OOP编程,而是OOP的补充,和数据库的触发器有点相似</p></li><li class="list__item" id="-i7x40f_9173"><p>主要内容 </p><ul class="list _bullet" id="-i7x40f_9174"><li class="list__item" id="-i7x40f_9175"><p>Aspect:配置文件,包括一些Pointcut和响应的Advice</p></li><li class="list__item" id="-i7x40f_9176"><p>JointPoint:在程序中明确定义的点,如方法调用,对类成员访问等</p></li><li class="list__item" id="-i7x40f_9177"><p>PointCut: 一组JointPoint,可以哦通过逻辑关系/通配符/正则等组合起来,定义了响应advice将要发生的地方</p></li><li class="list__item" id="-i7x40f_9178"><p>Advice:定义了在pointcut处要发生的动作,通过before/after/around来关联</p></li><li class="list__item" id="-i7x40f_9179"><p>weaving:advice代码在具体jointPoint的关联方式</p></li></ul></li></ul></section></section><section class="chapter"><h2 id="annotation" data-toc="annotation">注解Annotation</h2><ul class="list _bullet" id="-i7x40f_9180"><li class="list__item" id="-i7x40f_9181"><p>JDK1.5引入</p></li><li class="list__item" id="-i7x40f_9182"><p>位于源码中(代码/注释/注解),使用其他工具进行处理的标签</p></li><li class="list__item" id="-i7x40f_9183"><p>注解用来修饰程序的元素,但不会对修饰的对象有直接的影响</p></li><li class="list__item" id="-i7x40f_9184"><p>只有通过某种配套的工具才会对注解信息进行访问和处理</p></li><li class="list__item" id="-i7x40f_9185"><p>主要用途 </p><ul class="list _bullet" id="-i7x40f_9186"><li class="list__item" id="-i7x40f_9187"><p>提供信息给编译器/IDE工具</p></li><li class="list__item" id="-i7x40f_9188"><p>可用于其他工具来产生额外的代码/配置文件等</p></li><li class="list__item" id="-i7x40f_9189"><p>有一些注解可在程序运行时访问,增加程序动态性</p></li></ul></li><li class="list__item" id="-i7x40f_9190"><p>@SuppressWarning </p><ul class="list _bullet" id="-i7x40f_9191"><li class="list__item" id="-i7x40f_9192"><p>不同jdk 不同,javac -X可查看</p></li></ul></li></ul><section class="chapter"><h3 id="-i7x40f_9193" data-toc="-i7x40f_9193">自定义注解</h3><ul class="list _bullet" id="-i7x40f_9194"><li class="list__item" id="-i7x40f_9195"><p>注解可以包括的类型 </p><ul class="list _bullet" id="-i7x40f_9196"><li class="list__item" id="-i7x40f_9197"><p>8种基本类型</p></li><li class="list__item" id="-i7x40f_9198"><p>String</p></li><li class="list__item" id="-i7x40f_9199"><p>Class</p></li><li class="list__item" id="-i7x40f_9200"><p>enum</p></li><li class="list__item" id="-i7x40f_9201"><p>注解类型</p></li><li class="list__item" id="-i7x40f_9202"><p>由前面类型组成的数组</p></li></ul></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.Annotation;

public @interface BugReport {
    enum Status {UNCONFIRMED,CONFIRMED,FIXED, NOTABUG};

    boolean showStopper() default true;

    String assignedTo() default &quot;[notes]&quot;;

    Status status() default Status.UNCONFIRMED;

    String[] reportedBy();
}

</div><ul class="list _bullet" id="-i7x40f_9204"><li class="list__item" id="-i7x40f_9205"><p>注解使用的位置(@Target)</p></li><li class="list__item" id="-i7x40f_9206"><p>@Retention(RetentionPolicy.RUNTIME) 编译时也存在</p></li><li class="list__item" id="-i7x40f_9207"><p>自定义注解及其使用</p></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.Annotation.Single;

import java.lang.reflect.Method;

/**
 * @Description:
 * @author: Anhlaidh 
 * @date: 2020-08-05 17:18
 */
public class Main {
    public static void main(String[] args) throws ClassNotFoundException {
        int passed = 0, failed = 0;
        String className = &quot;notes.Java.Java_Final.Annotation.Single.Foo&quot;;
        for (Method m : Class.forName(className).getMethods()) {
            if (m.isAnnotationPresent(SingleTest.class)) {
                System.out.println(m.getName());
                SingleTest st = m.getAnnotation(SingleTest.class);
                try {
                    m.invoke(null, st.value());
                    passed++;
                } catch (Throwable throwable) {
                    System.out.printf(&quot;Test %s failed %s %n&quot;, m, throwable.getCause().getMessage());
                    failed++;
                }
            }
        }
        System.out.printf(&quot;Success: %d ,Failed: %d %n&quot;, passed, failed);
    }
}

</div></section><section class="chapter"><h3 id="-i7x40f_9209" data-toc="-i7x40f_9209">元注解</h3><ul class="list _bullet" id="-i7x40f_9210"><li class="list__item" id="-i7x40f_9211"><p id="-i7x40f_9212">修饰注解的注解</p></li><li class="list__item" id="-i7x40f_9213"><p id="-i7x40f_9214">@Target 设置目标范围</p><ul class="list _bullet" id="-i7x40f_9215"><li class="list__item" id="-i7x40f_9216"><p>限定目标注解作用于什么位置@Target()</p></li><li class="list__item" id="-i7x40f_9217"><p>ElementType.ANNOTATION_TYPE(注:修饰注解)</p></li><li class="list__item" id="-i7x40f_9218"><p>ElementType.CONSTRUCTOR</p></li><li class="list__item" id="-i7x40f_9219"><p>ElementType.FIELD</p></li><li class="list__item" id="-i7x40f_9220"><p>ElementType.LOCAL_VARIABLE</p></li><li class="list__item" id="-i7x40f_9221"><p>ElementType.METHOD</p></li><li class="list__item" id="-i7x40f_9222"><p>ElementType.PACKAGE</p></li><li class="list__item" id="-i7x40f_9223"><p>ElementType.PARAMETER</p></li><li class="list__item" id="-i7x40f_9224"><p>ElementType.TYPE(注:任何类型,即上面的类型都可以修饰)</p></li></ul></li><li class="list__item" id="-i7x40f_9225"><p id="-i7x40f_9226">@Retention 设置保持性</p><ul class="list _bullet" id="-i7x40f_9227"><li class="list__item" id="-i7x40f_9228"><p>修饰其他注解的存在范围</p></li><li class="list__item" id="-i7x40f_9229"><p>Retention.SOURCE 注解仅存在源码,不在class文件</p></li><li class="list__item" id="-i7x40f_9230"><p>Retention.CLASS(默认的注解保留策略) 注解存在于.class文件,不能被JVM加载</p></li><li class="list__item" id="-i7x40f_9231"><p>Retention.RUNTIME这种策略下,注解可以被JVM运行时访问到,通常情况下,可以结合反射来做一些事情</p></li></ul></li><li class="list__item" id="-i7x40f_9232"><p id="-i7x40f_9233">@Inherited 注解继承</p><ul class="list _bullet" id="-i7x40f_9234"><li class="list__item" id="-i7x40f_9235"><p>让一个类和他的子类都包含某个注解</p></li><li class="list__item" id="-i7x40f_9236"><p>普通的注解没有继承功能</p></li></ul></li><li class="list__item" id="-i7x40f_9237"><p id="-i7x40f_9238">@Repeatable 此注解可以重复修饰</p><ul class="list _bullet" id="-i7x40f_9239"><li class="list__item" id="-i7x40f_9240"><p>自jdk1.8引入</p></li><li class="list__item" id="-i7x40f_9241"><p>表示被修饰的注解可以重复应用标注</p></li><li class="list__item" id="-i7x40f_9242"><p>需要定义注解和容器注解</p></li></ul></li><li class="list__item" id="-i7x40f_9243"><p id="-i7x40f_9244">@Document 文档</p><ul class="list _bullet" id="-i7x40f_9245"><li class="list__item" id="-i7x40f_9246"><p>指明这个注解可以被javadoc工具解析,形成帮助文档</p></li></ul></li><li class="list__item" id="-i7x40f_9247"><p id="-i7x40f_9248">RUNTIME注解调用路线</p><ol class="list _decimal" id="-i7x40f_9249" type="1"><li class="list__item" id="-i7x40f_9250"><p>Java为注解产生一个代理类</p></li><li class="list__item" id="-i7x40f_9251"><p>这个代理类包括一个AnnotationInvocationHandler成员变量</p></li><li class="list__item" id="-i7x40f_9252"><p>AnnotationInvocationHandler有个Map的成员变量,用来存储所有的注解的属性赋值</p></li><li class="list__item" id="-i7x40f_9253"><p>在程序中,调用注解接口的方法,将会被代理类接管,然后根据方法名字,到Map里拿到对应的Value并返回</p></li></ol></li></ul></section></section><section class="chapter"><h2 id="nested-classes" data-toc="nested-classes">嵌套类 Nested classes</h2><ul class="list _bullet" id="-i7x40f_9254"><li class="list__item" id="-i7x40f_9255"><p id="-i7x40f_9256">静态嵌套类: Static nested classes,即前面有static修饰符</p><ul class="list _bullet" id="-i7x40f_9257"><li class="list__item" id="-i7x40f_9258"><p>层级和包围类(enclosing class)的成员变量/方法一样</p></li><li class="list__item" id="-i7x40f_9259"><p>静态嵌套类可以定义静态和非静态成员</p></li><li class="list__item" id="-i7x40f_9260"><p>第三方需要通过外部包围类才可以访问到静态嵌套类 </p><ul class="list _bullet" id="-i7x40f_9261"><li class="list__item" id="-i7x40f_9262"><p><code class="code" id="-i7x40f_9263">Outer.Inner obj = new Outer.Inner();</code></p></li></ul></li></ul></li><li class="list__item" id="-i7x40f_9264"><p id="-i7x40f_9265">非静态嵌套类: Non-static nested classes ,又名内部类,Inner classes</p><ul class="list _bullet" id="-i7x40f_9266"><li class="list__item" id="-i7x40f_9267"><p>普通内部类(成员内部类) </p><ul class="list _bullet" id="-i7x40f_9268"><li class="list__item" id="-i7x40f_9269"><p>非static的类,定义在某个类的成员变量位置</p></li><li class="list__item" id="-i7x40f_9270"><p>定义后在类里面均可以使用</p></li><li class="list__item" id="-i7x40f_9271"><p>在第三方类中,需要先创建外部包围类实例,才能创建内部类的实例,不允许单独的普通内部类对象存在 </p><ul class="list _bullet" id="-i7x40f_9272"><li class="list__item" id="-i7x40f_9273"><p><code class="code" id="-i7x40f_9274">Outer.Inner obj = Outer.new Inner();</code></p></li></ul></li></ul></li><li class="list__item" id="-i7x40f_9275"><p>局部内部类(Local classes) </p><ul class="list _bullet" id="-i7x40f_9276"><li class="list__item" id="-i7x40f_9277"><p>定义在代码块中的非静态的类,如方法,for循环,if语句等</p></li><li class="list__item" id="-i7x40f_9278"><p>定义后,即可创建对象使用</p></li><li class="list__item" id="-i7x40f_9279"><p>只能活在这个代码块中,代码块结束后,外界无法使用该类</p></li></ul></li><li class="list__item" id="-i7x40f_9280"><p>匿名内部类(Anonymous class) </p><ul class="list _bullet" id="-i7x40f_9281"><li class="list__item" id="-i7x40f_9282"><p>没有类名的内部类,必须继承一个父类/实现一个父接口</p></li><li class="list__item" id="-i7x40f_9283"><p>在实例化以后,迅速转型为父类/父接口</p></li><li class="list__item" id="-i7x40f_9284"><p>这种类型的对象,只能new一个对象,之后以对象名字操作</p></li><li class="list__item" id="-i7x40f_9285"><p>可在普通语句和成员变量赋值时使用内部类</p></li></ul></li></ul></li><li class="list__item" id="-i7x40f_9286"><p id="-i7x40f_9287">为什么需要嵌套类</p><ul class="list _bullet" id="-i7x40f_9288"><li class="list__item" id="-i7x40f_9289"><p>不同的访问权限要求,更细粒度的访问控制</p></li><li class="list__item" id="-i7x40f_9290"><p>简介,避免过多的类定义</p></li><li class="list__item" id="-i7x40f_9291"><p>语言设计过于复杂,较难学习和使用</p></li></ul><div class="table-wrapper"><table class="wide" id="-i7x40f_9292"><thead><tr class="ijRowHead" id="-i7x40f_9293"><th id="-i7x40f_9294"></th><th id="-i7x40f_9295"><p>位置</p></th><th id="-i7x40f_9296"><p>名字(编译后的class文件)</p></th><th id="-i7x40f_9297"><p>作用范围</p></th><th id="-i7x40f_9298"><p>基本信息</p></th><th id="-i7x40f_9299"><p>嵌套类内部的内容</p></th><th id="-i7x40f_9300"><p>可访问的外部包围类的内容</p></th><th id="-i7x40f_9301"><p>和外部类的关系</p></th></tr></thead><tbody><tr id="-i7x40f_9302"><td id="-i7x40f_9303"><p>匿名内部类</p></td><td id="-i7x40f_9304"><p>成员变量或者成员方法内</p></td><td id="-i7x40f_9305"><p>外部类名+$+数字编号</p></td><td id="-i7x40f_9306"><p>跟随被复制变量的作用范围, </p><br><p> 外界无法访问</p></td><td id="-i7x40f_9308"><p>没有类名,没有构造函数</p><br><p> 没有static,private/default/protected/public修饰</p></td><td id="-i7x40f_9310"><p>不能带静态成员</p></td><td id="-i7x40f_9311"><p>访问外部的所有成员</p></td><td id="-i7x40f_9312"><p>在外部类对象内部</p></td></tr><tr id="-i7x40f_9313"><td id="-i7x40f_9314"><p>局部内部类</p></td><td id="-i7x40f_9315"><p>成员方法内</p></td><td id="-i7x40f_9316"><p>外部类名+$+序号+内部类名</p></td><td id="-i7x40f_9317"><p>所在的方法内</p><br><p> 外界无法访问</p></td><td id="-i7x40f_9319"><p>有类名,有构造函数</p><br><p> 没有static,private/default/protected/public修饰</p></td><td id="-i7x40f_9321"><p>不能带静态成员,除了常量</p></td><td id="-i7x40f_9322"><p>访问外部的所有成员</p></td><td id="-i7x40f_9323"><p>在外部类的对象内部</p></td></tr><tr id="-i7x40f_9324"><td id="-i7x40f_9325"><p>普通内部类</p></td><td id="-i7x40f_9326"><p>成员变量</p></td><td id="-i7x40f_9327"><p>外部类名+$+内部类名</p></td><td id="-i7x40f_9328"><p>包围类内可以访问, </p><br><p> 外界可以访问</p></td><td id="-i7x40f_9330"><p>有类名,有构造函数</p><br><p> 没有static,private/default/protected/public修饰</p></td><td id="-i7x40f_9332"><p>不能带静态成员,除了常量</p></td><td id="-i7x40f_9333"><p>访问外部的所有成员</p></td><td id="-i7x40f_9334"><p>外界可以new, </p><br><p> 但是必须依附于一个外部包围类对象</p></td></tr><tr id="-i7x40f_9336"><td id="-i7x40f_9337"><p>静态嵌套类</p></td><td id="-i7x40f_9338"><p>成员变量</p></td><td id="-i7x40f_9339"><p>外部类名+$+内部类名</p></td><td id="-i7x40f_9340"><p>包围类内部可以访问, </p><br><p> 外界可以访问</p></td><td id="-i7x40f_9342"><p>有类名,有构造函数</p><br><p> 有static,private/default/protected/public修饰</p></td><td id="-i7x40f_9344"><p>可以定义静态成员变量和方法</p></td><td id="-i7x40f_9345"><p>访问外部的所有静态成员</p></td><td id="-i7x40f_9346"><p>可以new,可独立进行工作</p></td></tr></tbody></table></div></li><li class="list__item" id="-i7x40f_9347"><p id="-i7x40f_9348">变量遮蔽:Shadowing</p><ul class="list _bullet" id="-i7x40f_9349"><li class="list__item" id="-i7x40f_9350"><p>嵌套类变量和外部包围类的变量重名 </p><ul class="list _bullet" id="-i7x40f_9351"><li class="list__item" id="-i7x40f_9352"><p>以离得近作为优先原则</p></li><li class="list__item" id="-i7x40f_9353"><p>优先级高的变量回遮蔽优先级低的变量</p></li><li class="list__item" id="-i7x40f_9354"><p>外部包围类.this.变量名,可以访问到外部包围类的成员变量</p></li><li class="list__item" id="-i7x40f_9355"><p>静态嵌套类不能访问非静态变量</p></li><li class="list__item" id="-i7x40f_9356"><p>Java7及以前,匿名内部类和局部内部类只能访问外部包围类的final成员变量</p></li><li class="list__item" id="-i7x40f_9357"><p>Java8及以后,匿名内部类和局部内部类可以访问外部包围类的final成员变量和 事实意义上的final变量(effectively final,一个变量定值后,再也没有改过值)</p></li></ul></li></ul></li></ul></section><section class="chapter"><h2 id="lambda" data-toc="lambda">Lambda表达式</h2><ul class="list _bullet" id="-i7x40f_9358"><li class="list__item" id="-i7x40f_9359"><p>参数,箭头,一个表达式</p></li><li class="list__item" id="-i7x40f_9360"><p>参数,箭头,{多个语句}</p></li><li class="list__item" id="-i7x40f_9361"><p>类似于匿名方法,一个没有名字的方法</p></li><li class="list__item" id="-i7x40f_9362"><p>参数,箭头,表达式语句</p></li><li class="list__item" id="-i7x40f_9363"><p>可以忽略写参数类型</p></li><li class="list__item" id="-i7x40f_9364"><p>坚决不声明返回值类型</p></li><li class="list__item" id="-i7x40f_9365"><p>没有public/protected/private/static/final等修饰符</p></li><li class="list__item" id="-i7x40f_9366"><p>单句表达式,将直接返回值,不用大括号</p></li><li class="list__item" id="-i7x40f_9367"><p>带return语句,算多句,必须用大括号</p></li></ul><section class="chapter"><h3 id="-i7x40f_9368" data-toc="-i7x40f_9368">函数式接口</h3><ul class="list _bullet" id="-i7x40f_9369"><li class="list__item" id="-i7x40f_9370"><p>是一个接口,符合Java接口的定义</p></li><li class="list__item" id="-i7x40f_9371"><p>只包含一个抽象方法的接口</p></li><li class="list__item" id="-i7x40f_9372"><p>可以包含其他的default方法,static方法,private方法</p></li><li class="list__item" id="-i7x40f_9373"><p>由于只有一个未实现的方法,所以Lambda表达式可以自动填上这个尚未实现的方法</p></li><li class="list__item" id="-i7x40f_9374"><p>采用Lambda表达式,可以自动创建出一个(伪)嵌套类的对象(没有实际嵌套类class文件产生),然后使用, 比真正嵌套类更加轻量,更加简洁高效</p></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.Lambda;
@FunctionalInterface
//标记为函数式接口
public interface StringChecker {
    public boolean test(String s);
}

</div><div class="code-block" data-lang="java">
package notes.Java.Java_Final.Lambda;

/**
 * @Description:
 * @author: Anhlaidh
 * @date: 2020-08-06 21:38
 */
public class Main {
    public static void main(String[] args) {
        String[] s = new String[]{&quot;aaa&quot;, &quot;bbbb&quot;, &quot;cccccc&quot;};
        StringChecker eventLength = s1 -&gt; {
            if (s1.length() % 2 == 0) {
                return true;
            }
            return false;
        };

        for (String p : s) {
            if (eventLength.test(p)) {
                System.out.println(p);

            }
        }
    }

}

</div></section><section class="chapter"><h3 id="-i7x40f_9377" data-toc="-i7x40f_9377">系统自带的函数式接口</h3><div class="table-wrapper"><table class="wide" id="-i7x40f_9378"><thead><tr class="ijRowHead" id="-i7x40f_9379"><th id="-i7x40f_9380"><p>接口</p></th><th id="-i7x40f_9381"><p>参数</p></th><th id="-i7x40f_9382"><p>返回值</p></th><th id="-i7x40f_9383"><p>实例</p></th></tr></thead><tbody><tr id="-i7x40f_9384"><td id="-i7x40f_9385"><p>Predicate</p></td><td id="-i7x40f_9387"><p>T</p></td><td id="-i7x40f_9388"><p>Boolean</p></td><td id="-i7x40f_9389"><p>接收一个参数,返回一个boolean</p></td></tr><tr id="-i7x40f_9390"><td id="-i7x40f_9391"><p>Consumer</p></td><td id="-i7x40f_9393"><p>T</p></td><td id="-i7x40f_9394"><p>void</p></td><td id="-i7x40f_9395"><p>接受一个参数,无返回</p></td></tr><tr id="-i7x40f_9396"><td id="-i7x40f_9397"><p>Function&lt;T,R&gt;</p></td><td id="-i7x40f_9398"><p>T</p></td><td id="-i7x40f_9399"><p>R</p></td><td id="-i7x40f_9400"><p>接受一个参数,返回一个值</p></td></tr><tr id="-i7x40f_9401"><td id="-i7x40f_9402"><p>Supplier</p></td><td id="-i7x40f_9404"><p>None</p></td><td id="-i7x40f_9405"><p>T</p></td><td id="-i7x40f_9406"><p>数据工厂</p></td></tr></tbody></table></div></section><section class="chapter"><h3 id="-i7x40f_9407" data-toc="-i7x40f_9407">方法引用</h3><ul class="list _bullet" id="-i7x40f_9408"><li class="list__item" id="-i7x40f_9409"><p>Class::staticMethod</p></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.Lambda;

/**
 * @Description:
 * @author: Anhlaidh
 * @date: 2020-08-06 22:26
 */
public class method {
    public static void main(String[] args) {
        double a = -3.5;
        double b = worker(Math::abs, a);
        System.out.println(b);
        double c = worker(Math::floor, a);
        System.out.println(c);
        double d = worker((num -&gt; (num % 10)), a);
        System.out.println(d);

    }

    public static double worker(NumFunction nf, double num) {
        return nf.calculate(num);
    }
}

</div><ul class="list _bullet" id="-i7x40f_9411"><li class="list__item" id="-i7x40f_9412"><p>Class::instanceMethod </p><ul class="list _bullet" id="-i7x40f_9413"><li class="list__item" id="-i7x40f_9414"><p>第一个参数将变成方法的执行体</p></li><li class="list__item" id="-i7x40f_9415"><p>String::compareToIgnoreCase等价于(x,y)-&gt;x.compareToIgnoreCase(y)</p></li><li class="list__item" id="-i7x40f_9416"><div class="code-block" data-lang="none">
    String[] planets = new String[]{&quot;DDD&quot;,&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;};
    Arrays.sort(planets, String::compareToIgnoreCase);
    System.out.println(Arrays.toString(planets));
</div></li></ul></li><li class="list__item" id="-i7x40f_9418"><p>object::instanceMethod </p><ul class="list _bullet" id="-i7x40f_9419"><li class="list__item" id="-i7x40f_9420"><p>支持this::instanceMethod</p></li><li class="list__item" id="-i7x40f_9421"><p>支持super::instanceMethod</p></li></ul></li><li class="list__item" id="-i7x40f_9422"><p>Class::new,调用某类构造函数,支持单个对象构建</p></li><li class="list__item" id="-i7x40f_9423"><p>Class[]::new,调用某类构造函数,支持数组对象构建</p></li><li class="list__item" id="-i7x40f_9424"><p>应用</p></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.Lambda;

import java.util.ArrayList;
import java.util.Arrays;

/**
 * @Description:
 * @author: Anhlaidh
 * @date: 2020-08-07 15:06
 */
public class testIterable {
    public static void main(String[] args) {
        String[] p = new String[]{&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;};
        ArrayList&lt;String&gt; pList = new ArrayList&lt;String&gt;(Arrays.asList(p));
        for (String s : pList) {
            System.out.println(s);
        }
        pList.forEach(System.out::println);

    }
}

</div></section></section><section class="chapter"><h2 id="stream" data-toc="stream">流 stream</h2><ul class="list _bullet" id="-i7x40f_9426"><li class="list__item" id="-i7x40f_9427"><p>sequence of elements:一个流对外提供一个接口,可以访问到一串特定的数据,流不存储元素,但是可以根据需要进行计算转化</p></li><li class="list__item" id="-i7x40f_9428"><p>source:数据来源,如数据结构,数组,文件等</p></li><li class="list__item" id="-i7x40f_9429"><p>aggregate operation:聚合操作,流支持像SQL操作或者其他函数式语言的操作 如filter/map/reduce/find/match/sorted等</p></li><li class="list__item" id="-i7x40f_9430"><p>Stream流 </p><ul class="list _bullet" id="-i7x40f_9431"><li class="list__item" id="-i7x40f_9432"><p>pipelining:很多流操作也是返回一个流</p></li><li class="list__item" id="-i7x40f_9433"><p>Internal Iteration:流操作进行迭代,用户感知不到循环遍历</p></li></ul></li></ul><section class="chapter"><h3 id="-i7x40f_9434" data-toc="-i7x40f_9434">流的工作流程</h3><ol class="list _decimal" id="-i7x40f_9435" type="1"><li class="list__item" id="-i7x40f_9436"><p>流的创建 </p><ul class="list _bullet" id="-i7x40f_9437"><li class="list__item" id="-i7x40f_9438"><p>Collection接口的stream方法</p></li><li class="list__item" id="-i7x40f_9439"><p>Arrays.stream(数组)</p></li><li class="list__item" id="-i7x40f_9440"><p>Stream.of()</p></li><li class="list__item" id="-i7x40f_9441"><p>empty() 空流</p></li><li class="list__item" id="-i7x40f_9442"></li></ul></li><li class="list__item" id="-i7x40f_9443"><p>流的转换,将流转换为其他流的中间操作,可包括多个步骤(惰性操作)</p></li><li class="list__item" id="-i7x40f_9444"><p>流的计算结果,这个操作会强制执行之前的惰性操作,这个步骤以后,流就再也不用了</p></li></ol></section></section><div class="last-modified">Last modified: 30 四月 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="java-2.html" class="navigation-links__prev">java-2</a><a href="jvm-2.html" class="navigation-links__next">JVM</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b259/app.js"></script></body></html>