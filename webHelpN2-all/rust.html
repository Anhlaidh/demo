<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2024-04-30T19:02:50.607682"><title>Rust | Notes</title><script type="application/json" id="virtual-toc-data">[{"id":"i67twel_1918","level":0,"title":"特点","anchor":"#i67twel_1918"},{"id":"i67twel_1972","level":0,"title":"入门","anchor":"#i67twel_1972"},{"id":"i67twel_2547","level":0,"title":"问题","anchor":"#i67twel_2547"},{"id":"i67twel_2551","level":0,"title":"附录","anchor":"#i67twel_2551"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b259/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Rust | Notes"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Notes Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/rust.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Rust | Notes"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/rust.html#webpage",
    "url": "writerside-documentation/rust.html",
    "name": "Rust | Notes",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Notes Help"
}</script><!-- End Schema.org --></head><body data-id="Rust" data-main-title="Rust" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Notes///Rust"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Notes  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Rust" id="Rust.md">Rust</h1><p id="i67twel_1916"><a href="https://kaisery.github.io/trpl-zh-cn/ch05-03-method-syntax.html" id="i67twel_1917" data-external="true" rel="noopener noreferrer">Rust权威指南</a></p><section class="chapter"><h2 id="i67twel_1918" data-toc="i67twel_1918">特点</h2><ul class="list _bullet" id="i67twel_1919"><li class="list__item" id="i67twel_1920"><p>预编译</p></li><li class="list__item" id="i67twel_1921"><p>强类型</p></li><li class="list__item" id="i67twel_1922"><p>类型隐藏</p></li></ul><section class="chapter"><h3 id="java" data-toc="java">与java不同点</h3><ul class="list _bullet" id="i67twel_1923"><li class="list__item" id="i67twel_1924"><p id="i67twel_1925">变量不能二次赋值</p><ul class="list _bullet" id="i67twel_1926"><li class="list__item" id="i67twel_1927"><p id="i67twel_1928">如果需要二次赋值，需声明mut，即 <code class="code" id="i67twel_1929">let mut [var]</code></p><aside class="prompt" data-type="tip" data-title="" id="i67twel_1930"><p id="i67twel_1931">Rust认为，应该显式地区分可变于不可变，声明可变说明允许变量被修改, 默认不可变是因为，根据统计，一般而言不被修改的变量要比被修改的变量多 不可变变量，有利于防止一些傻*修改了本来不应该修改的值，导致发生灾难</p></aside></li></ul></li><li class="list__item" id="i67twel_1932"><p id="i67twel_1933">占位符 {} 类比log4j</p><ul class="list _bullet" id="i67twel_1934"><li class="list__item" id="i67twel_1935"><p>需要实现std::fmt::display</p></li><li class="list__item" id="i67twel_1936"><p>结构体打印可用<code class="code" id="i67twel_1937">{:?}</code>或<code class="code" id="i67twel_1938">{:#?}</code></p><ul class="list _bullet" id="i67twel_1939"><li class="list__item" id="i67twel_1940"><p>需添加std::fmt::Debug</p></li><li class="list__item" id="i67twel_1941"><p><code class="code" id="i67twel_1942">#[derive(Debug)]</code></p></li></ul></li></ul></li><li class="list__item" id="i67twel_1943"><p id="i67twel_1944">在需要类型转换时，可以对同一个变量多次声明</p></li><li class="list__item" id="i67twel_1945"><p id="i67twel_1946">move</p><aside class="prompt" data-type="tip" data-title="" id="i67twel_1947"><p id="i67twel_1948">为了保证内存安全，Rust不会尝试复制被分配的内存</p><p id="i67twel_1949">以string为例，s1=&quot;abc&quot;，s2=s1时，在java中，s2，s1都会指向heap的&quot;abc&quot;，且只有s1，s2都出作用域之后，对&quot;abc&quot;进行gc操作</p><p id="i67twel_1950">某些语言中，会在s1离开作用域后，进行一次drop操作，s2离开时会再重复一次，导致二次回收的bug</p><p id="i67twel_1951">在rust中，为了解决这个问题，在s2=s1之后，s1就失效了，此时调用s1，则会 <code class="code" id="i67twel_1952">value borrowed here after move</code></p></aside><ul class="list _bullet" id="i67twel_1953"><li class="list__item" id="i67twel_1954"><p id="i67twel_1955">在指针传入函数后，相当于进行了move操作，就失效了</p></li><li class="list__item" id="i67twel_1956"><p id="i67twel_1957">返回值也会有所有权转交的性质</p></li><li class="list__item" id="i67twel_1958"><p id="i67twel_1959">一旦struct的实例是可变的，那么实例中所有字段都是可变的</p></li><li class="list__item" id="i67twel_1960"><p id="i67twel_1961">枚举类型变体可以为不同的类型</p><aside class="prompt" data-type="tip" data-title="" id="i67twel_1962"><div class="code-block" data-lang="none">
enum IpAddressKind{
    V4(u8,u8,u8,u8),
    V6(String)
}
</div></aside></li><li class="list__item" id="i67twel_1964"><p id="i67twel_1965">rust没有null</p></li><li class="list__item" id="i67twel_1966"><p id="i67twel_1967">rust 所有条目默认为private</p></li><li class="list__item" id="i67twel_1968"><p id="i67twel_1969">rust UT允许测试私有函数</p></li><li class="list__item" id="i67twel_1970"><p id="i67twel_1971">文档注释支持markdown</p></li></ul></li></ul></section></section><section class="chapter"><h2 id="i67twel_1972" data-toc="i67twel_1972">入门</h2><ul class="list _bullet" id="i67twel_1973"><li class="list__item" id="i67twel_1974"><p>IDE vscode</p></li><li class="list__item" id="i67twel_1975"><p>振奋人心的hello world</p></li><li class="list__item" id="i67twel_1976"><p>编译命令 rustc 生成二进制文件</p></li></ul><section class="chapter"><h3 id="cargo" data-toc="cargo">cargo</h3><div class="code-block" data-lang="none">
[package]
name = &quot;rustLearning&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
rand = &quot;0.8.5&quot;
</div><ul class="list _bullet" id="i67twel_1978"><li class="list__item" id="i67twel_1979"><p>创建项目：cargo new </p><ul class="list _bullet" id="i67twel_1980"><li class="list__item" id="i67twel_1981"><p>Cargo.toml </p><ul class="list _bullet" id="i67twel_1982"><li class="list__item" id="i67twel_1983"><p>Cargo配置文件 </p><ul class="list _bullet" id="i67twel_1984"><li class="list__item" id="i67twel_1985"><p>依赖列表</p></li></ul></li></ul></li><li class="list__item" id="i67twel_1986"><p>src </p><ul class="list _bullet" id="i67twel_1987"><li class="list__item" id="i67twel_1988"><p>源代码</p></li></ul></li><li class="list__item" id="i67twel_1989"><p>Cargo.lock</p></li></ul></li><li class="list__item" id="i67twel_1990"><p>构建项目 </p><ul class="list _bullet" id="i67twel_1991"><li class="list__item" id="i67twel_1992"><p>cargo build </p><ul class="list _bullet" id="i67twel_1993"><li class="list__item" id="i67twel_1994"><p>生成cargo.lock文件 </p><ul class="list _bullet" id="i67twel_1995"><li class="list__item" id="i67twel_1996"><p>精确依赖版本</p></li></ul></li><li class="list__item" id="i67twel_1997"><p>cargo run 编译+执行二进制文件 /target/debug</p></li><li class="list__item" id="i67twel_1998"><p>cargo check 编译（比build快)</p></li><li class="list__item" id="i67twel_1999"><p>cargo build --release 发布构建 /target/release</p></li></ul></li></ul></li><li class="list__item" id="i67twel_2000"><p>依赖管理 </p><ul class="list _bullet" id="i67twel_2001"><li class="list__item" id="i67twel_2002"><p>Cargo.lock</p></li><li class="list__item" id="i67twel_2003"><p>Cargo.toml</p></li><li class="list__item" id="i67twel_2004"><p>Cargo build </p><ul class="list _bullet" id="i67twel_2005"><li class="list__item" id="i67twel_2006"><p>不修改版本号时，则根据Cargo.lock 编译</p></li><li class="list__item" id="i67twel_2007"><p>否则更新依赖</p></li></ul></li><li class="list__item" id="i67twel_2008"><p>Cargo update </p><ul class="list _bullet" id="i67twel_2009"><li class="list__item" id="i67twel_2010"><p>根据 toml编译，并将Cargo.lock更新为当前版本的最新小版本，[0.8.max]</p></li></ul></li></ul></li></ul></section><section class="chapter"><h3 id="demo" data-toc="demo">DEMO</h3><ul class="list _bullet" id="i67twel_2011"><li class="list__item" id="i67twel_2012"><p>生成随机数小游戏</p></li><li class="list__item" id="i67twel_2013"><p>声明变量 let </p><ul class="list _bullet" id="i67twel_2014"><li class="list__item" id="i67twel_2015"><p>显式声明变量类型 <code class="code" id="i67twel_2016">let [var] : [type]</code></p><ul class="list _bullet" id="i67twel_2017"><li class="list__item" id="i67twel_2018"><p>let guess: u32</p></li></ul></li></ul></li><li class="list__item" id="i67twel_2019"><p>io::stdin</p></li><li class="list__item" id="i67twel_2020"><section class="chapter"><h4 id="match" data-toc="match">match</h4></section></li><li class="list__item" id="i67twel_2021"><p>循环 </p><ul class="list _bullet" id="i67twel_2022"><li class="list__item" id="i67twel_2023"><p id="i67twel_2024">loop</p><aside class="prompt" data-type="tip" data-title="" id="i67twel_2025"><p id="i67twel_2026">使用loop进行无限循环，而不是while ture，while在rust中侧重于condition，而不是true，体现了rust的设计哲学：高度一致性 正如match中最后一个ram后面，可选择加逗号，语句一致性</p></aside></li></ul></li></ul></section><section class="chapter"><h3 id="rust" data-toc="rust">Rust</h3><section class="chapter"><h4 id="i67twel_2027" data-toc="i67twel_2027">变量常量</h4><ul class="list _bullet" id="i67twel_2028"><li class="list__item" id="i67twel_2029"><p>变量与可变性 </p><ul class="list _bullet" id="i67twel_2030"><li class="list__item" id="i67twel_2031"><p>声明变量用let</p></li><li class="list__item" id="i67twel_2032"><p>默认情况变量不可变（immutable)</p></li><li class="list__item" id="i67twel_2033"><p><code class="code" id="i67twel_2034">cannot assign twice to immutable variable</code></p></li></ul></li><li class="list__item" id="i67twel_2035"><p>常量 </p><ul class="list _bullet" id="i67twel_2036"><li class="list__item" id="i67twel_2037"><p>不可以用mut</p></li><li class="list__item" id="i67twel_2038"><p>用const关键字，类型必须被标注</p></li><li class="list__item" id="i67twel_2039"><p>可以在任何作用域声明，包括全局作用域</p></li><li class="list__item" id="i67twel_2040"><p>只可以绑定到常量表达式，无法绑定到函数的调用结果或只能在运行时才能计算的值 ==&gt;静态值？</p></li><li class="list__item" id="i67twel_2041"><p>命名规范与java相同</p></li></ul></li><li class="list__item" id="i67twel_2042"><p>shadowing </p><ul class="list _bullet" id="i67twel_2043"><li class="list__item" id="i67twel_2044"><p>可以使用相同的名字声明新的变量，新的变量会shadow之前的变量</p></li><li class="list__item" id="i67twel_2045"><p>后续代码中这个变量名则代表新的变量</p></li></ul></li></ul></section><section class="chapter"><h4 id="i67twel_2046" data-toc="i67twel_2046">数据类型</h4><ul class="list _bullet" id="i67twel_2047"><li class="list__item" id="i67twel_2048"><p>标量类型和复合类型 </p><ul class="list _bullet" id="i67twel_2049"><li class="list__item" id="i67twel_2050"><p>基于使用的值，编译器通常能推断出具体类型</p></li><li class="list__item" id="i67twel_2051"><p>可能的类型比较多，则需要添加类型标注</p></li><li class="list__item" id="i67twel_2052"><p>标量类型 </p><ul class="list _bullet" id="i67twel_2053"><li class="list__item" id="i67twel_2054"><p>一个标量类型表示一个单一的值</p></li><li class="list__item" id="i67twel_2055"><p>四种类型 </p><ul class="list _bullet" id="i67twel_2056"><li class="list__item" id="i67twel_2057"><p>整数类型 </p><ul class="list _bullet" id="i67twel_2058"><li class="list__item" id="i67twel_2059"><p>isize usize</p></li><li class="list__item" id="i67twel_2060"><p>除了byte之外，都允许使用类型后缀，57u8</p></li><li class="list__item" id="i67twel_2061"><p>默认i32</p></li><li class="list__item" id="i67twel_2062"><p>整数溢出 </p><ul class="list _bullet" id="i67twel_2063"><li class="list__item" id="i67twel_2064"><p>把u8的值设为256 </p><ul class="list _bullet" id="i67twel_2065"><li class="list__item" id="i67twel_2066"><p>调试模式下编译：Rust检查整数溢出，如果发生溢出，则程序在运行时会panic</p></li><li class="list__item" id="i67twel_2067"><p>发布模式下（--release）编译，rust不会检查可能导致Panic的整数溢出 </p><ul class="list _bullet" id="i67twel_2068"><li class="list__item" id="i67twel_2069"><p>如果发生溢出，rust会执行&quot;环绕&quot;操作 </p><ul class="list _bullet" id="i67twel_2070"><li class="list__item" id="i67twel_2071"><p>256变成0，257变成1</p></li><li class="list__item" id="i67twel_2072"><p>但程序不回panic</p></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="list__item" id="i67twel_2073"><p>浮点类型 </p><ul class="list _bullet" id="i67twel_2074"><li class="list__item" id="i67twel_2075"><p>f32</p></li><li class="list__item" id="i67twel_2076"><p>f64 默认</p></li></ul></li><li class="list__item" id="i67twel_2077"><p>bool </p><ul class="list _bullet" id="i67twel_2078"><li class="list__item" id="i67twel_2079"><p>true</p></li><li class="list__item" id="i67twel_2080"><p>false</p></li></ul></li><li class="list__item" id="i67twel_2081"><p>字符 </p><ul class="list _bullet" id="i67twel_2082"><li class="list__item" id="i67twel_2083"><p>与java相同</p></li></ul></li></ul></li></ul></li><li class="list__item" id="i67twel_2084"><p>复合类型 </p><ul class="list _bullet" id="i67twel_2085"><li class="list__item" id="i67twel_2086"><p>将多个值放在一个类型里面</p></li><li class="list__item" id="i67twel_2087"><p>rust提供两种基础的复合类型：元组（tuple）、数组 </p><ul class="list _bullet" id="i67twel_2088"><li class="list__item" id="i67twel_2089"><p>Tuple </p><ul class="list _bullet" id="i67twel_2090"><li class="list__item" id="i67twel_2091"><p>Tuple可以将多个类型的值放到一个类型里面</p></li><li class="list__item" id="i67twel_2092"><p>Tuple的长度是固定的，一旦声明无法改变</p></li></ul></li><li class="list__item" id="i67twel_2093"><p>数组 </p><ul class="list _bullet" id="i67twel_2094"><li class="list__item" id="i67twel_2095"><p>数据存放在栈(stack)内存上</p></li><li class="list__item" id="i67twel_2096"><p>没有vector灵活</p></li><li class="list__item" id="i67twel_2097"><p><code class="code" id="i67twel_2098">let [var]:[type;length]</code> 例如： <code class="code" id="i67twel_2099">let a:[i32:5]</code></p><ul class="list _bullet" id="i67twel_2100"><li class="list__item" id="i67twel_2101"><p>设置默认值： <code class="code" id="i67twel_2102">let a=[3;5]</code>即 <code class="code" id="i67twel_2103">let a=[3,3,3,3,3]</code></p></li><li class="list__item" id="i67twel_2104"><p>超出数组范围时，编译不报错，运行时panic</p></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></section><section class="chapter"><h4 id="i67twel_2105" data-toc="i67twel_2105">函数</h4><div class="code-block" data-lang="rust">
fn function(x: i32, y: String) {
}
</div><ul class="list _bullet" id="i67twel_2107"><li class="list__item" id="i67twel_2108"><p>命名规范 python xx_xx</p></li><li class="list__item" id="i67twel_2109"><p>参数</p></li><li class="list__item" id="i67twel_2110"><p>语句与表达式 </p><ul class="list _bullet" id="i67twel_2111"><li class="list__item" id="i67twel_2112"><p>语句无返回值，不能用let将一个语句赋值给一个变量</p></li></ul></li><li class="list__item" id="i67twel_2113"><p>函数返回值 </p><ul class="list _bullet" id="i67twel_2114"><li class="list__item" id="i67twel_2115"><p>在-&gt;符号后面声明函数返回值的类型，但是不能为返回值命名</p></li><li class="list__item" id="i67twel_2116"><p>rust里，返回值就是函数体最后一个表达式的值</p></li><li class="list__item" id="i67twel_2117"><p>若想提前返回，需要return</p></li></ul></li></ul></section><section class="chapter"><h4 id="i67twel_2118" data-toc="i67twel_2118">控制流</h4><section class="chapter"><h5 id="if-else" data-toc="if-else">if else</h5><div class="code-block" data-lang="rust">
if x &gt; 5 {
        return y;
    }else {
        return x.to_string() 
    }
</div><ul class="list _bullet" id="i67twel_2120"><li class="list__item" id="i67twel_2121"><p>if是表达式，可以放在 = 右边，给变量赋值</p></li></ul><div class="code-block" data-lang="rust">
return if x &gt; 5 {
        y
    } else {
        x.to_string()
    }
</div></section><section class="chapter"><h5 id="i67twel_2123" data-toc="i67twel_2123">循环</h5><ul class="list _bullet" id="i67twel_2124"><li class="list__item" id="i67twel_2125"><p>loop</p></li><li class="list__item" id="i67twel_2126"><p>while</p></li><li class="list__item" id="i67twel_2127"><p>for </p><ul class="list _bullet" id="i67twel_2128"><li class="list__item" id="i67twel_2129"><p>遍历集合 </p><ul class="list _bullet" id="i67twel_2130"><li class="list__item" id="i67twel_2131"><p><code class="code" id="i67twel_2132">for element in a.iter(){}</code></p></li></ul></li><li class="list__item" id="i67twel_2133"><p>range </p><ul class="list _bullet" id="i67twel_2134"><li class="list__item" id="i67twel_2135"><p>标准库提供</p></li><li class="list__item" id="i67twel_2136"><p>指定一个开始和结束，range生成他们之间的数字（左闭右开）</p></li><li class="list__item" id="i67twel_2137"><p>rev方法可以反转range</p></li><li class="list__item" id="i67twel_2138"><p><code class="code" id="i67twel_2139">for number in (1..4).rev(){}</code></p></li></ul></li></ul></li></ul></section></section><section class="chapter"><h4 id="i67twel_2140" data-toc="i67twel_2140">所有权</h4><ul class="list _bullet" id="i67twel_2141"><li class="list__item" id="i67twel_2142"><p>rust核心特性</p></li><li class="list__item" id="i67twel_2143"><p>解决垃圾回收，内存释放 </p><ul class="list _bullet" id="i67twel_2144"><li class="list__item" id="i67twel_2145"><p>对于某个值来说，拥有它的变量走出作用范围时，内存会立即自动交还给操作系统</p></li></ul></li><li class="list__item" id="i67twel_2146"><p>内存管理提前到了编译阶段</p></li></ul><section class="chapter"><h5 id="stack-vs-heap" data-toc="stack-vs-heap">Stack vs Heap</h5><ul class="list _bullet" id="i67twel_2147"><li class="list__item" id="i67twel_2148"><p>Stack vs Heap </p><ul class="list _bullet" id="i67twel_2149"><li class="list__item" id="i67twel_2150"><p>写数据 </p><ul class="list _bullet" id="i67twel_2151"><li class="list__item" id="i67twel_2152"><p>把值压到stack上不叫分配</p></li><li class="list__item" id="i67twel_2153"><p>指针在stack上</p></li><li class="list__item" id="i67twel_2154"><p>数据压到stack上比heap快很多</p></li><li class="list__item" id="i67twel_2155"><p>heap上分配空间需要更多工作</p></li></ul></li><li class="list__item" id="i67twel_2156"><p>读数据 </p><ul class="list _bullet" id="i67twel_2157"><li class="list__item" id="i67twel_2158"><p>类比java内存模型</p></li></ul></li></ul></li></ul></section><section class="chapter"><h5 id="i67twel_2159" data-toc="i67twel_2159">所有权规则</h5><ol class="list _decimal" id="i67twel_2160" type="1"><li class="list__item" id="i67twel_2161"><p>每个值都有一个变量，这个变量是这个值的所有者</p></li><li class="list__item" id="i67twel_2162"><p>每个值同时只能有一个所有者</p></li><li class="list__item" id="i67twel_2163"><p>当所有者超出作用域（scope）时，该值将被删除</p></li></ol><ul class="list _bullet" id="i67twel_2164"><li class="list__item" id="i67twel_2165"><p id="i67twel_2166">变量和数据的交互方式 ：move</p><aside class="prompt" data-type="tip" data-title="" id="i67twel_2167"><p id="i67twel_2168">s1=&quot;abc&quot; s2=s1 s1失效</p></aside><ul class="list _bullet" id="i67twel_2169"><li class="list__item" id="i67twel_2170"><p>浅拷贝</p></li><li class="list__item" id="i67twel_2171"><p>深拷贝 clone</p></li><li class="list__item" id="i67twel_2172"><p>rust中在将s2指针指向&quot;abc&quot;后，对s1进行了失效操作，对此称为&quot;move&quot;</p></li></ul></li><li class="list__item" id="i67twel_2173"><p id="i67twel_2174">copy trait 可以用于像整数这样完全存放在stack上面的类型</p><ul class="list _bullet" id="i67twel_2175"><li class="list__item" id="i67twel_2176"><p>除了四种标量类型，tuple如果都是标量，那么也具有copy trait</p></li></ul></li><li class="list__item" id="i67twel_2177"><p id="i67twel_2178">总结： 在一个作用域结束的时候，heap上的值要么被drop掉，要么被转交</p></li><li class="list__item" id="i67twel_2179"><p id="i67twel_2180">那么如何让函数使用某个值，但不获取所有权</p><ol class="list _decimal" id="i67twel_2181" type="1"><li class="list__item" id="i67twel_2182"><p>函数传入自己，再返回元组的时候把自己返回出来（非常麻烦）</p></li><li class="list__item" id="i67twel_2183"><p>引用</p></li></ol></li></ul><section class="chapter"><h6 id="i67twel_2184" data-toc="i67twel_2184">引用 借用</h6><ul class="list _bullet" id="i67twel_2185"><li class="list__item" id="i67twel_2186"><p id="i67twel_2187"><code class="code" id="i67twel_2188">&amp;</code>表示引用</p></li><li class="list__item" id="i67twel_2189"><p id="i67twel_2190">规则</p><ul class="list _bullet" id="i67twel_2191"><li class="list__item" id="i67twel_2192"><p>在任何给定的时刻，只能满足下列条件之一 </p><ul class="list _bullet" id="i67twel_2193"><li class="list__item" id="i67twel_2194"><p>一个可变的引用</p></li><li class="list__item" id="i67twel_2195"><p>任意数量不可变的引用 </p><ul class="list _bullet" id="i67twel_2196"><li class="list__item" id="i67twel_2197"><p>可以通过创建新的作用域，来允许非同时创建多个可变引用</p></li></ul></li></ul></li><li class="list__item" id="i67twel_2198"><p>引用必须一直有效</p></li></ul></li><li class="list__item" id="i67twel_2199"><p id="i67twel_2200">引用跟变量一样，默认是不可变的，同时可以加mut转为可变引用</p></li><li class="list__item" id="i67twel_2201"><p id="i67twel_2202">借用</p><ul class="list _bullet" id="i67twel_2203"><li class="list__item" id="i67twel_2204"><p>把引用作为函数参数的行为叫做借用</p></li></ul></li><li class="list__item" id="i67twel_2205"><p id="i67twel_2206">悬空引用（Dangling pointer）</p><ul class="list _bullet" id="i67twel_2207"><li class="list__item" id="i67twel_2208"><p>一个指针引用了内存中的某个地址，而这块内存可能已经释放并分配给其他人使用了</p></li><li class="list__item" id="i67twel_2209"><p>rust编译器保证引用永远都不是悬空引用 </p><ul class="list _bullet" id="i67twel_2210"><li class="list__item" id="i67twel_2211"><p>如果你引用了某些数据，编译器将保证在引用离开作用域前数据不会离开作用域</p></li></ul></li></ul></li></ul></section><section class="chapter"><h6 id="i67twel_2212" data-toc="i67twel_2212">切片</h6><ul class="list _bullet" id="i67twel_2213"><li class="list__item" id="i67twel_2214"><p>rust的另一种不持有所有权的数据类型：切片</p></li><li class="list__item" id="i67twel_2215"><p>slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合</p></li><li class="list__item" id="i67twel_2216"><p>字符串字面值就是 slice</p></li></ul></section><section class="chapter"><h6 id="struct" data-toc="struct">struct</h6><ul class="list _bullet" id="i67twel_2217"><li class="list__item" id="i67twel_2218"><p>类比thrift</p></li><li class="list__item" id="i67twel_2219"><p>一旦struct的实例是可变的，那么实例中所有字段都是可变的</p></li><li class="list__item" id="i67twel_2220"><p>（语法糖）字段值跟变量名相同时，构造时可以简写</p></li><li class="list__item" id="i67twel_2221"><p>struct更新语法</p></li><li class="list__item" id="i67twel_2222"><p>tuple struct </p><ul class="list _bullet" id="i67twel_2223"><li class="list__item" id="i67twel_2224"><p>整体有名，元素没有名</p></li></ul></li><li class="list__item" id="i67twel_2225"><p>unit-like struct </p><ul class="list _bullet" id="i67twel_2226"><li class="list__item" id="i67twel_2227"><p>没有任何字段</p></li></ul></li><li class="list__item" id="i67twel_2228"><p>默认拥有所有字段所有权 </p><ul class="list _bullet" id="i67twel_2229"><li class="list__item" id="i67twel_2230"><p>也可以拥有引用，需要生命周期保证</p></li></ul></li><li class="list__item" id="i67twel_2231"><p>定义方法 </p><ul class="list _bullet" id="i67twel_2232"><li class="list__item" id="i67twel_2233"><p>impl [struct_name]</p></li></ul></li></ul></section><section class="chapter"><h6 id="i67twel_2234" data-toc="i67twel_2234">枚举</h6><ul class="list _bullet" id="i67twel_2235"><li class="list__item" id="i67twel_2236"><p>枚举类型变体可以为不同的类型</p></li><li class="list__item" id="i67twel_2237"><p>枚举方法</p></li><li class="list__item" id="i67twel_2238"><p>Option </p><ul class="list _bullet" id="i67twel_2239"><li class="list__item" id="i67twel_2240"><p>标准库</p></li><li class="list__item" id="i67twel_2241"><p>某个值可能存在（某种类型）或不存在的情况</p></li><li class="list__item" id="i67twel_2242"><p>内容 </p><ul class="list _bullet" id="i67twel_2243"><li class="list__item" id="i67twel_2244"><p>some</p></li><li class="list__item" id="i67twel_2245"><p>None</p></li></ul></li></ul></li></ul></section><section class="chapter"><h6 id="match" data-toc="match">match</h6><ul class="list _bullet" id="i67twel_2246"><li class="list__item" id="i67twel_2247"><p>必须穷举所有的可能 </p><ul class="list _bullet" id="i67twel_2248"><li class="list__item" id="i67twel_2249"><p><code class="code" id="i67twel_2250">_</code>通配符表示其余的可能，default</p></li></ul></li></ul></section><section class="chapter"><h6 id="if-let" data-toc="if-let">if let</h6><ul class="list _bullet" id="i67twel_2251"><li class="list__item" id="i67twel_2252"><p>match 一个（模式匹配）</p></li></ul></section></section></section><section class="chapter"><h4 id="i67twel_2253" data-toc="i67twel_2253">代码组织</h4><ul class="list _bullet" id="i67twel_2254"><li class="list__item" id="i67twel_2255"><p>lib项目 </p><ul class="list _bullet" id="i67twel_2256"><li class="list__item" id="i67twel_2257"><p>cargo new xxx --lib</p></li></ul></li><li class="list__item" id="i67twel_2258"><p>main项目 </p><ul class="list _bullet" id="i67twel_2259"><li class="list__item" id="i67twel_2260"><p>cargo new xxx</p></li></ul></li></ul><section class="chapter"><h5 id="super-pub-struct-enum" data-toc="super-pub-struct-enum">super pub struct enum</h5><ul class="list _bullet" id="i67twel_2261"><li class="list__item" id="i67twel_2262"><p>默认private，因此需要叫pub关键字</p></li><li class="list__item" id="i67twel_2263"><p>enum加完pub，所有变体都将pub</p></li></ul></section></section><section class="chapter"><h4 id="i67twel_2264" data-toc="i67twel_2264">集合</h4><ul class="list _bullet" id="i67twel_2265"><li class="list__item" id="i67twel_2266"><p>Vector </p><ul class="list _bullet" id="i67twel_2267"><li class="list__item" id="i67twel_2268"><p>Vec</p><p> 类比java new 一个list</p></li><li class="list__item" id="i67twel_2270"><p>初始宏： <code class="code" id="i67twel_2271">let v = vec![1,2,3];</code></p></li><li class="list__item" id="i67twel_2272"><p>写 </p><ul class="list _bullet" id="i67twel_2273"><li class="list__item" id="i67twel_2274"><p>push</p></li></ul></li><li class="list__item" id="i67twel_2275"><p>读 </p><ul class="list _bullet" id="i67twel_2276"><li class="list__item" id="i67twel_2277"><p>索引 编译时会检查索引是否超出，类比数组</p></li><li class="list__item" id="i67twel_2278"><p>get 返回option</p></li></ul></li></ul></li><li class="list__item" id="i67twel_2280"><p>String </p><ul class="list _bullet" id="i67twel_2281"><li class="list__item" id="i67twel_2282"><p>String是对Vec</p><p> 的包装</p></li><li class="list__item" id="i67twel_2284"><p>不能直接索引</p></li><li class="list__item" id="i67twel_2285"><p>bytes for遍历</p></li><li class="list__item" id="i67twel_2286"><p>chars for遍历 字型蔟</p></li><li class="list__item" id="i67twel_2287"><p>默认utf-8</p></li><li class="list__item" id="i67twel_2288"><p>可以切片 对于可变字节切片，遇到边界问题，程序会panic</p></li><li class="list__item" id="i67twel_2289"><p>HashMap &lt;k,v&gt; </p><ul class="list _bullet" id="i67twel_2290"><li class="list__item" id="i67twel_2291"><p id="i67twel_2292">HashMap::new()</p><ul class="list _bullet" id="i67twel_2293"><li class="list__item" id="i67twel_2294"><p>写 </p><ul class="list _bullet" id="i67twel_2295"><li class="list__item" id="i67twel_2296"><p>insert方法会move所有权，当然也可以传引用 </p><ul class="list _bullet" id="i67twel_2297"><li class="list__item" id="i67twel_2298"><p>相同key则覆盖</p></li></ul></li><li class="list__item" id="i67twel_2299"><p>entry or_insert() </p><ul class="list _bullet" id="i67twel_2300"><li class="list__item" id="i67twel_2301"><p>entry方法返回是否存在对应key</p></li></ul></li></ul></li></ul></li><li class="list__item" id="i67twel_2302"><p id="i67twel_2303">zip collect</p></li><li class="list__item" id="i67twel_2304"><div class="code-block" data-lang="rust">
fn main() {
  let teams = vec![&quot;Blue&quot;.to_string(), &quot;Yellow&quot;.to_string()];
  let scores = vec![10, 20];
  let map: HashMap&lt;_, _&gt; = teams.iter().zip(scores.iter()).collect();
  let string = format!(&quot;{:?}&quot;, map);
  print!(&quot;map: {}&quot;, string);
}

</div><aside class="prompt" data-type="tip" data-title="" id="i67twel_2306"><p id="i67twel_2307">zip()接受一个参数，将调用者中的元素与参数中的元素一一对应组成Tuple，若数量不匹配，多的元素会丢掉 collect()方法在形成了一个HashMap，元素的顺序并不固定，每一次run都可能不一样 当然key -&gt; value的顺序是由zip一一对应的，不是有collect决定的，请搞清楚</p></aside></li></ul></li></ul></li></ul></section><section class="chapter"><h4 id="i67twel_2308" data-toc="i67twel_2308">错误处理</h4><ul class="list _bullet" id="i67twel_2309"><li class="list__item" id="i67twel_2310"><p>panic </p><ul class="list _bullet" id="i67twel_2311"><li class="list__item" id="i67twel_2312"><p>自己代码中</p></li><li class="list__item" id="i67twel_2313"><p>依赖中</p></li><li class="list__item" id="i67twel_2314"><p>可以调用panic的回溯信息来定位问题代码</p></li><li class="list__item" id="i67twel_2315"><p>设置环境变量 RUST_BACKTRACE=1可得到回溯信息 </p><ul class="list _bullet" id="i67twel_2316"><li class="list__item" id="i67twel_2317"><p>MacOS使用： RUST_BACKTRACE=1 cargo run</p></li></ul></li></ul></li><li class="list__item" id="i67twel_2318"><p>Result枚举 </p><ul class="list _bullet" id="i67twel_2319"><li class="list__item" id="i67twel_2320"><p>match处理 </p><ul class="list _bullet" id="i67twel_2321"><li class="list__item" id="i67twel_2322"><p>unwrap 成功则返回对应值，否则panic，不能指定panic信息</p></li><li class="list__item" id="i67twel_2323"><p>expect 成功则返回对应值，否则panic，能指定panic信息</p></li></ul></li></ul></li><li class="list__item" id="i67twel_2324"><p>传播错误 （throw e） </p><ul class="list _bullet" id="i67twel_2325"><li class="list__item" id="i67twel_2326"><p>return Result&lt;T,io::Error&gt;</p></li><li class="list__item" id="i67twel_2327"><p>? 运算符 </p><ul class="list _bullet" id="i67twel_2328"><li class="list__item" id="i67twel_2329"><p>只能用于返回Result&lt;T,E&gt;的函数</p></li><li class="list__item" id="i67twel_2330"><p>main函数返回类型也可以为 Result&lt;T,E&gt;, <code class="code" id="i67twel_2331">Result&lt;(),Box&lt;dyn Error&gt;&gt;</code></p><ul class="list _bullet" id="i67twel_2332"><li class="list__item" id="i67twel_2333"><p><code class="code" id="i67twel_2334">Box&lt;dyn Error&gt;&gt;</code>可以简单理解为&quot;任何可能的错误类型&quot;</p></li></ul></li></ul></li><li class="list__item" id="i67twel_2335"><p>?与from</p></li></ul></li><li class="list__item" id="i67twel_2336"><p>什么时候用panic</p></li></ul></section><section class="chapter"><h4 id="trait" data-toc="trait">泛型 trait 生命周期</h4><ul class="list _bullet" id="i67twel_2337"><li class="list__item" id="i67twel_2338"><p>泛型</p></li><li class="list__item" id="i67twel_2339"><p>Trait 把方法签名放在一起来定义实现某种目的所必须的一组行为（类比interface） </p><ul class="list _bullet" id="i67twel_2340"><li class="list__item" id="i67twel_2341"><p>关键字 trait</p></li><li class="list__item" id="i67twel_2342"><p>只有方法签名，没有具体实现（可以有默认实现）</p></li><li class="list__item" id="i67twel_2343"><p>trait可以有多个方法：每个方法签名占一行，以<code class="code" id="i67twel_2344">;</code>结尾</p></li><li class="list__item" id="i67twel_2345"><p>实现trait的类型必须提供具体的方法实现</p></li><li class="list__item" id="i67twel_2346"><p>impl trait_name for struct_name{}</p></li><li class="list__item" id="i67twel_2347"><p>实现trait的约束 </p><ul class="list _bullet" id="i67twel_2348"><li class="list__item" id="i67twel_2349"><p>可以在某个类型上实现某个trait的前提条件是：这个类型或这个trait是在本地crate里定义的</p></li><li class="list__item" id="i67twel_2350"><p>无法为外部类型实现外部的trait </p><ul class="list _bullet" id="i67twel_2351"><li class="list__item" id="i67twel_2352"><p>这个限制是程序属性的一部分：一致性</p></li><li class="list__item" id="i67twel_2353"><p>孤儿规则：之所以这样命名是因为父类型不存在</p></li><li class="list__item" id="i67twel_2354"><p>此规则确保其他人的代码不能破坏你的代码，反之亦然</p></li><li class="list__item" id="i67twel_2355"><p>如果没有这个规则，两个crate可以为同一个</p></li></ul></li><li class="list__item" id="i67twel_2356"><p>作为参数 </p><ul class="list _bullet" id="i67twel_2357"><li class="list__item" id="i67twel_2358"><p><code class="code" id="i67twel_2359">fn a(a: impl trait_name +trait_2_name) -&gt; i32 {}</code></p></li><li class="list__item" id="i67twel_2360"><p>trait bound写法 <code class="code" id="i67twel_2361">fn notify&lt;T: trait_name+trait_2_name &gt;(item: T){}</code></p><ul class="list _bullet" id="i67twel_2362"><li class="list__item" id="i67twel_2363"><p>where写法 <code class="code" id="i67twel_2364">fn notify&lt;T &gt;(item: T) where T:trait_1_name+trait_2_name,...{}</code></p></li></ul></li></ul></li><li class="list__item" id="i67twel_2365"><p>作为返回值 <code class="code" id="i67twel_2366">fn a()-&gt; impl trait_1_name+trait_2_name</code></p><ul class="list _bullet" id="i67twel_2367"><li class="list__item" id="i67twel_2368"><p>impl trait 只能返回确定的同一种类型，返回可能不同的类型的代码会报错</p></li></ul></li></ul></li></ul></li><li class="list__item" id="i67twel_2369"><p>生命周期 </p><ul class="list _bullet" id="i67twel_2370"><li class="list__item" id="i67twel_2371"><p>rust的每个引用都有自己的生命周期</p></li><li class="list__item" id="i67twel_2372"><p>借用检查器</p></li><li class="list__item" id="i67twel_2373"><p>生命周期：引用保持有效的作用域</p></li><li class="list__item" id="i67twel_2374"><p>大多数情况：生命周期是隐式的、可被推断的</p></li><li class="list__item" id="i67twel_2375"><p>当引用的生命周期可能以不同的方式相互关联时：手动标注生命周期</p></li><li class="list__item" id="i67twel_2376"><p>语法 </p><ul class="list _bullet" id="i67twel_2377"><li class="list__item" id="i67twel_2378"><p>形如<code class="code" id="i67twel_2379">'a</code> 以<code class="code" id="i67twel_2380">'</code>开头，</p></li><li class="list__item" id="i67twel_2381"><p>生命周期标注位置（个人理解：以调用出发，先考虑传进去引用的参数的作用范围，再考量函数中生命周期的标注） </p><ul class="list _bullet" id="i67twel_2382"><li class="list__item" id="i67twel_2383"><p>在引用的&amp;后</p></li><li class="list__item" id="i67twel_2384"><p>空格将标注与引用类型分开</p></li></ul></li></ul></li><li class="list__item" id="i67twel_2385"><p>生命周期省略的三个规则（同样适用于fn和impl） </p><ol class="list _decimal" id="i67twel_2386" type="1"><li class="list__item" id="i67twel_2387"><p>每个引用类型的参数都有自己的生命周期</p></li><li class="list__item" id="i67twel_2388"><p>如果只有1个输入生命周期参数，那么该生命周期被赋予给所有的输出生命周期参数</p></li><li class="list__item" id="i67twel_2389"><p>如果有多个输入生命周期参数，但其中一个是&amp;self或&amp;mut self（是方法），那么self的生命周期会被赋予给所有的输出生命周期参数</p></li></ol></li><li class="list__item" id="i67twel_2390"><section class="chapter"><h5 id="i67twel_2391" data-toc="i67twel_2391">结构体方法生命周期语法</h5></section></li><li class="list__item" id="i67twel_2392"><p>静态生命周期 <code class="code" id="i67twel_2393">'static</code></p></li></ul></li></ul></section><section class="chapter"><h4 id="i67twel_2394" data-toc="i67twel_2394">测试</h4><ul class="list _bullet" id="i67twel_2395"><li class="list__item" id="i67twel_2396"><p id="i67twel_2397">cargo test</p><ul class="list _bullet" id="i67twel_2398"><li class="list__item" id="i67twel_2399"><p>会执行 包含<code class="code" id="i67twel_2400">#[Test]</code> attribute的方法 </p><ul class="list _bullet" id="i67twel_2401"><li class="list__item" id="i67twel_2402"><p><code class="code" id="i67twel_2403">#[Ignore]</code></p></li></ul></li><li class="list__item" id="i67twel_2404"><p>默认行为 </p><ul class="list _bullet" id="i67twel_2405"><li class="list__item" id="i67twel_2406"><p>并行运行 </p><ul class="list _bullet" id="i67twel_2407"><li class="list__item" id="i67twel_2408"><p>确保不回相互依赖，不依赖共享状态，或指定单线程</p></li></ul></li><li class="list__item" id="i67twel_2409"><p>所有测试</p></li></ul></li><li class="list__item" id="i67twel_2410"><p>命令行参数 </p><ul class="list _bullet" id="i67twel_2411"><li class="list__item" id="i67twel_2412"><p>--test-threads</p></li><li class="list__item" id="i67twel_2413"><p>cargo test --help</p></li><li class="list__item" id="i67twel_2414"><p>cargo test -- --help</p></li></ul></li></ul></li><li class="list__item" id="i67twel_2415"><p id="i67twel_2416">测试失败</p><ul class="list _bullet" id="i67twel_2417"><li class="list__item" id="i67twel_2418"><p>panic!</p></li><li class="list__item" id="i67twel_2419"><p>Assert </p><ul class="list _bullet" id="i67twel_2420"><li class="list__item" id="i67twel_2421"><p>assert! 判断true，false</p></li><li class="list__item" id="i67twel_2422"><p>assert_eq! &amp; assert_nq!</p></li><li class="list__item" id="i67twel_2423"><p>自定义错误信息，最后一个参数传打印内容，支持format</p></li></ul></li></ul></li><li class="list__item" id="i67twel_2424"><p id="i67twel_2425"><code class="code" id="i67twel_2426">#[should_panic]</code></p><ul class="list _bullet" id="i67twel_2427"><li class="list__item" id="i67twel_2428"><p>发生panic成功，未发生则失败</p></li><li class="list__item" id="i67twel_2429"><p>expected 标注panic的返回信息</p></li></ul></li><li class="list__item" id="i67twel_2430"><p id="i67twel_2431">Result&lt;T,E&gt;</p></li><li class="list__item" id="i67twel_2432"><p id="i67twel_2433">单元测试</p><ul class="list _bullet" id="i67twel_2434"><li class="list__item" id="i67twel_2435"><p>mod标注 <code class="code" id="i67twel_2436">#[cfg(Test)]</code></p></li><li class="list__item" id="i67twel_2437"><p>rust允许测试私有函数</p></li></ul></li><li class="list__item" id="i67twel_2438"><p id="i67twel_2439">集成测试</p><ul class="list _bullet" id="i67twel_2440"><li class="list__item" id="i67twel_2441"><p>tests目录 cargo test时才会编译 </p><ul class="list _bullet" id="i67twel_2442"><li class="list__item" id="i67twel_2443"><p>common 目录 tests的公共目录，不会被视为test crate</p></li></ul></li></ul></li><li class="list__item" id="i67twel_2444"><p id="i67twel_2445">binary crate 的集成测试</p><ul class="list _bullet" id="i67twel_2446"><li class="list__item" id="i67twel_2447"><p>没有lib.rs时 不能 在tests下创建集成测试，无法把main.rs的函数导入作用域</p></li></ul></li></ul></section><section class="chapter"><h4 id="demo" data-toc="demo">命令行程序DEMO</h4></section><section class="chapter"><h4 id="i67twel_2448" data-toc="i67twel_2448">闭包</h4><ul class="list _bullet" id="i67twel_2449"><li class="list__item" id="i67twel_2450"><p>闭包 </p><ul class="list _bullet" id="i67twel_2451"><li class="list__item" id="i67twel_2452"><p>匿名函数</p></li><li class="list__item" id="i67twel_2453"><p>保存为变量、作为参数</p></li><li class="list__item" id="i67twel_2454"><p>可在一个地方创建闭包，然后在另一个上下文中调用闭包来完成运算</p></li><li class="list__item" id="i67twel_2455"><p>可从其定义的作用域捕获值</p></li></ul></li></ul></section><section class="chapter"><h4 id="i67twel_2456" data-toc="i67twel_2456">迭代器</h4><ul class="list _bullet" id="i67twel_2457"><li class="list__item" id="i67twel_2458"><p>类比java函数式编程</p></li></ul></section><section class="chapter"><h4 id="cargo-crates-io" data-toc="cargo-crates-io">cargo crates.io</h4><ul class="list _bullet" id="i67twel_2459"><li class="list__item" id="i67twel_2460"><p>类比maven? </p><ul class="list _bullet" id="i67twel_2461"><li class="list__item" id="i67twel_2462"><p>profile</p></li></ul></li><li class="list__item" id="i67twel_2463"><p>cargo doc</p></li></ul></section><section class="chapter"><h4 id="i67twel_2464" data-toc="i67twel_2464">智能指针</h4><section class="chapter"><h5 id="box" data-toc="box">Box</h5><ul class="list _bullet" id="i67twel_2467"><li class="list__item" id="i67twel_2468"><p>特点 </p><ul class="list _bullet" id="i67twel_2469"><li class="list__item" id="i67twel_2470"><p>允许在heap上存储数据</p></li><li class="list__item" id="i67twel_2471"><p>stack上是指向heap数据的指针</p></li><li class="list__item" id="i67twel_2472"><p>没有性能开销以及其他额外功能</p></li></ul></li><li class="list__item" id="i67twel_2473"><p>场景 </p><ul class="list _bullet" id="i67twel_2474"><li class="list__item" id="i67twel_2475"><p>编译时大小无法确定，上下文需要知道确切大小</p></li><li class="list__item" id="i67twel_2476"><p>大量数据要移交所有权，需要确保操作时数据不会被复制</p></li><li class="list__item" id="i67twel_2477"><p>使用某个值只关心是否实现了特定trait，不用关心具体类型 </p><ul class="list _bullet" id="i67twel_2478"><li class="list__item" id="i67twel_2479"><p>例如&quot;链表&quot; Cons list </p><ul class="list _bullet" id="i67twel_2480"><li class="list__item" id="i67twel_2481"><p>用Box来包装</p></li></ul></li></ul></li></ul></li></ul></section><section class="chapter"><h5 id="deref" data-toc="deref">Deref</h5><ul class="list _bullet" id="i67twel_2482"><li class="list__item" id="i67twel_2483"><p id="i67twel_2484">例如String 和&amp;str?</p><ul class="list _bullet" id="i67twel_2485"><li class="list__item" id="i67twel_2486"><p>在参数判断类型时发生不一致，发生解引用</p></li><li class="list__item" id="i67twel_2487"><p>MyBox实现了deref trait，且MyBox是封装的String，那么MyBox可以被解引用为&amp;str</p></li></ul></li><li class="list__item" id="i67twel_2488"><p id="i67twel_2489">具有解引用的能力</p></li><li class="list__item" id="i67twel_2490"><p id="i67twel_2491">本质上是 *（deref())，所以返回的是引用类型</p></li><li class="list__item" id="i67twel_2492"><p id="i67twel_2493">解引用与可变性</p></li><li class="list__item" id="i67twel_2494"><p id="i67twel_2495">drop trait</p><ul class="list _bullet" id="i67twel_2496"><li class="list__item" id="i67twel_2497"><p>自定义值将要离开作用域时发生的动作</p></li><li class="list__item" id="i67twel_2498"><p>drop(c) 手动清理内存</p></li></ul></li><li class="list__item" id="i67twel_2499"><p id="i67twel_2500">Rc 引用计数</p><ul class="list _bullet" id="i67twel_2502"><li class="list__item" id="i67twel_2503"><p>Rc::clone(&amp;a) 增加引用 不可变引用 </p><ul class="list _bullet" id="i67twel_2504"><li class="list__item" id="i67twel_2505"><p>与clone方法的区别，Rc clone是clone指针，标准拷贝，clone是深拷贝</p></li></ul></li><li class="list__item" id="i67twel_2506"><p>Rc::strong_count(&amp;a) 获得引用计数（强引用） </p><ul class="list _bullet" id="i67twel_2507"><li class="list__item" id="i67twel_2508"><p>weak_count 弱引用</p></li></ul></li></ul></li><li class="list__item" id="i67twel_2509"><p id="i67twel_2510">内部可变性 允许在只持有不可变引用的前提下对数据进行修改，unsafe</p></li><li class="list__item" id="i67twel_2511"><p id="i67twel_2512">RefCell</p></li></ul></section></section><section class="chapter"><h4 id="i67twel_2514" data-toc="i67twel_2514">无畏并发</h4><ul class="list _bullet" id="i67twel_2515"><li class="list__item" id="i67twel_2516"><p>thread::spawn </p><ul class="list _bullet" id="i67twel_2517"><li class="list__item" id="i67twel_2518"><p>返回类型 joinHandle</p></li></ul></li><li class="list__item" id="i67twel_2519"><p>消息传递 </p><ul class="list _bullet" id="i67twel_2520"><li class="list__item" id="i67twel_2521"><p>go：不要用共享内存来通信，要用通信来共享内存</p></li><li class="list__item" id="i67twel_2522"><p>Channel 进行通信，支持多个发送方，一个消费方</p></li><li class="list__item" id="i67twel_2523"><p>也支持共享内存 </p><ul class="list _bullet" id="i67twel_2524"><li class="list__item" id="i67twel_2525"><p>Mutex 相当于多线程中的RefCell,需要先lock，再使用 </p><ul class="list _bullet" id="i67twel_2526"><li class="list__item" id="i67twel_2527"><p>用Arc</p><p> 封装使用，不能用Rc :Rc不支持多线程，需要实现Send方法才可以多线程</p></li></ul></li></ul></li></ul></li><li class="list__item" id="i67twel_2529"><p>Send和 Sync trait </p><ul class="list _bullet" id="i67twel_2530"><li class="list__item" id="i67twel_2531"><p>自己实现并发</p></li><li class="list__item" id="i67twel_2532"><p>Send 允许线程间转移所有权 </p><ul class="list _bullet" id="i67twel_2533"><li class="list__item" id="i67twel_2534"><p>实现Send trait 的类型可在线程间转移所有权</p></li><li class="list__item" id="i67twel_2535"><p>Rust中几乎所有类型都实现了Send，除了Rc</p></li><li class="list__item" id="i67twel_2536"><p>任何完全由Send类型组成的类型也被标记为Send</p></li><li class="list__item" id="i67twel_2537"><p>除了原始指针之外，几乎所有的基础类型都是Send</p></li></ul></li><li class="list__item" id="i67twel_2538"><p>Sync 允许从多线程访问 </p><ul class="list _bullet" id="i67twel_2539"><li class="list__item" id="i67twel_2540"><p>实现Sync的类型可以安全的被多个线程引用</p></li><li class="list__item" id="i67twel_2541"><p>T是Sync 那么&amp;T就是Send </p><ul class="list _bullet" id="i67twel_2542"><li class="list__item" id="i67twel_2543"><p>引用可以被安全的送往另一个县城</p></li></ul></li><li class="list__item" id="i67twel_2544"><p>基础类型都是Sync</p></li><li class="list__item" id="i67twel_2545"><p>完全由Sync类型组成的类型也是Sync</p></li><li class="list__item" id="i67twel_2546"></li></ul></li></ul></li></ul></section></section></section><section class="chapter"><h2 id="i67twel_2547" data-toc="i67twel_2547">问题</h2><div class="code-block" data-lang="rust">
let mut guess = String::new();
loop{
io::stdin().read_line(&amp;mut guess).expect(&quot;无法读取&quot;);
}
</div><p id="i67twel_2549">不能重新read</p><div class="code-block" data-lang="rust">
fn main() {
    let mut v = vec![1, 2, 3, 4, 5];
    let a = &amp;v[0];
    // v.push(6);
    println!(&quot;{}&quot;, a);
}
//如何在取完v[0]引用之后再像v中添加元素
</div></section><section class="chapter"><h2 id="i67twel_2551" data-toc="i67twel_2551">附录</h2><p id="i67twel_2552">vec-&gt;array</p><div class="code-block" data-lang="rust">
 #[test]
fn aes_test() {
  let decode = &amp;base64::decode(&quot;MTIzNDU2Nzg5MDEyMzQ1Ng==&quot;).unwrap()[..];
  let vec = &lt;&amp; [u8;16]&gt;::try_from(decode);
  println!(&quot;{:?}&quot;, vec);
}
</div></section><div class="last-modified">Last modified: 30 四月 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="c-01.html" class="navigation-links__prev">C#基础</a><a href="部署.html" class="navigation-links__next">部署</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b259/app.js"></script></body></html>