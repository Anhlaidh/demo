<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2024-04-30T19:02:50.596455"><title>Table of Contents | Notes</title><script type="application/json" id="virtual-toc-data">[{"id":"imlsmr_1394","level":0,"title":"算法","anchor":"#imlsmr_1394"},{"id":"imlsmr_1395","level":0,"title":"基础","anchor":"#imlsmr_1395"},{"id":"imlsmr_1555","level":0,"title":"数据结构","anchor":"#imlsmr_1555"},{"id":"imlsmr_1754","level":0,"title":"递归","anchor":"#imlsmr_1754"},{"id":"imlsmr_1806","level":0,"title":"贪心算法","anchor":"#imlsmr_1806"},{"id":"imlsmr_1845","level":0,"title":"暴力递归","anchor":"#imlsmr_1845"},{"id":"imlsmr_1937","level":0,"title":"动态规划","anchor":"#imlsmr_1937"},{"id":"imlsmr_1993","level":0,"title":"预处理","anchor":"#imlsmr_1993"},{"id":"imlsmr_1995","level":0,"title":"问题范围和问题答案是否有线性规律","anchor":"#imlsmr_1995"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b259/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Table of Contents | Notes"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Notes Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/java-算法.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Table of Contents | Notes"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/java-算法.html#webpage",
    "url": "writerside-documentation/java-算法.html",
    "name": "Table of Contents | Notes",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Notes Help"
}</script><!-- End Schema.org --></head><body data-id="Java_算法" data-main-title="Table of Contents" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Notes///java///notes///Java"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Notes  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Java_算法" id="Java_算法.md">Table of Contents</h1><ul class="list _bullet" id="imlsmr_1336"><li class="list__item" id="imlsmr_1337"><p><span id="imlsmr_1338">算法</span></p><ul class="list _bullet" id="imlsmr_1339"><li class="list__item" id="imlsmr_1340"><p><span id="imlsmr_1341">基础</span></p><ul class="list _bullet" id="imlsmr_1342"><li class="list__item" id="imlsmr_1343"><p><span id="imlsmr_1344">工具</span></p></li><li class="list__item" id="imlsmr_1345"><p><span id="imlsmr_1346">运算</span></p></li><li class="list__item" id="imlsmr_1347"><p><span id="imlsmr_1348">排序</span></p></li></ul></li><li class="list__item" id="imlsmr_1349"><p><span id="imlsmr_1350">数据结构</span></p><ul class="list _bullet" id="imlsmr_1351"><li class="list__item" id="imlsmr_1352"><p><span id="imlsmr_1353">链表</span></p><ul class="list _bullet" id="imlsmr_1354"><li class="list__item" id="imlsmr_1355"><p><span id="imlsmr_1356">快慢指针</span></p></li></ul></li><li class="list__item" id="imlsmr_1357"><p><span id="imlsmr_1358">栈</span></p></li><li class="list__item" id="imlsmr_1359"><p><span id="imlsmr_1360">队列</span></p></li><li class="list__item" id="imlsmr_1361"><p><span id="imlsmr_1362">HashSet&amp;HashMap</span></p></li><li class="list__item" id="imlsmr_1363"><p><span id="imlsmr_1364">有序表</span></p></li><li class="list__item" id="imlsmr_1365"><p><span id="imlsmr_1366">堆</span></p></li><li class="list__item" id="imlsmr_1367"><p><span id="imlsmr_1368">二叉树</span></p><ul class="list _bullet" id="imlsmr_1369"><li class="list__item" id="imlsmr_1370"><p><span id="imlsmr_1371">递归序</span></p></li><li class="list__item" id="imlsmr_1372"><p><span id="imlsmr_1373">序列化反序列化</span></p></li><li class="list__item" id="imlsmr_1374"><p><span id="imlsmr_1375">题目</span></p></li><li class="list__item" id="imlsmr_1376"><p><span id="imlsmr_1377">二叉树的递归套路***</span></p><ul class="list _bullet" id="imlsmr_1378"><li class="list__item" id="imlsmr_1379"><p><span id="imlsmr_1380">规则</span></p></li><li class="list__item" id="imlsmr_1381"><p><span id="imlsmr_1382">题目</span></p></li></ul></li></ul></li><li class="list__item" id="imlsmr_1383"><p><span id="imlsmr_1384">前缀树</span></p></li></ul></li><li class="list__item" id="imlsmr_1385"><p><span id="imlsmr_1386">递归</span></p></li><li class="list__item" id="imlsmr_1387"><p><span id="imlsmr_1388">预处理</span></p><ul class="list _bullet" id="imlsmr_1389"><li class="list__item" id="imlsmr_1390"><p><span id="imlsmr_1391">前缀和求数组滚动窗口和</span></p></li></ul></li><li class="list__item" id="imlsmr_1392"><p><span id="imlsmr_1393">问题范围和问题答案是否有线性规律</span></p></li></ul></li></ul><section class="chapter"><h2 id="imlsmr_1394" data-toc="imlsmr_1394">算法</h2></section><section class="chapter"><h2 id="imlsmr_1395" data-toc="imlsmr_1395">基础</h2><section class="chapter"><h3 id="imlsmr_1396" data-toc="imlsmr_1396">工具</h3><ul class="list _bullet" id="imlsmr_1397"><li class="list__item" id="imlsmr_1398"><p id="imlsmr_1399">对数器</p><ul class="list _bullet" id="imlsmr_1400"><li class="list__item" id="imlsmr_1401"><p>一个想要测的方法a</p></li><li class="list__item" id="imlsmr_1402"><p>实现复杂度不好但是容易实现的方法b</p></li><li class="list__item" id="imlsmr_1403"><p>实现一个随机样本产生器</p></li><li class="list__item" id="imlsmr_1404"><p>方法a和方法b相同的随机样本,看看得到的结果是否一样</p></li><li class="list__item" id="imlsmr_1405"><p>如果一个随机样本使得比对结果不一致,打印样本进行人工干预,改对方法a和方法b</p></li><li class="list__item" id="imlsmr_1406"><p>当样本数量很多时对比测试依然正确,可以确定方法a已经正确</p></li></ul></li><li class="list__item" id="imlsmr_1407"><p id="imlsmr_1408">比较器</p><ol class="list _decimal" id="imlsmr_1409" type="1"><li class="list__item" id="imlsmr_1410"><p>比较器的实质是重载比较运算符</p></li><li class="list__item" id="imlsmr_1411"><p>比较器可以很好的应用在特殊标准的排序上</p></li><li class="list__item" id="imlsmr_1412"><p>比较器可以很好的应用在根据特殊标准排序的结构上 </p><ul class="list _bullet" id="imlsmr_1413"><li class="list__item" id="imlsmr_1414"><p>PriorityQueue 小根堆转大根堆</p></li></ul></li><li class="list__item" id="imlsmr_1415"><p>写代码变得异常容易,还用于泛型编程</p></li></ol></li></ul></section><section class="chapter"><h3 id="imlsmr_1416" data-toc="imlsmr_1416">运算</h3><ul class="list _bullet" id="imlsmr_1417"><li class="list__item" id="imlsmr_1418"><p>异或运算,二进制无进位相加 </p><ul class="list _bullet" id="imlsmr_1419"><li class="list__item" id="imlsmr_1420"><p>性质:0<span id="imlsmr_1421"><sup class="superscript">N=N,N</sup></span>N=0</p></li><li class="list__item" id="imlsmr_1422"><p>满足交换律和结合律(同一批数异或答案一样,无论顺序)</p></li><li class="list__item" id="imlsmr_1423"><p>ab互换 </p><ol class="list _decimal" id="imlsmr_1424" type="1"><li class="list__item" id="imlsmr_1425"><p>a = a^b</p></li><li class="list__item" id="imlsmr_1426"><p>b = a^b</p></li><li class="list__item" id="imlsmr_1427"><p>a = a^b</p></li></ol><ul class="list _bullet" id="imlsmr_1428"><li class="list__item" id="imlsmr_1429"><p>ab必须指向不同内存</p></li></ul></li><li class="list__item" id="imlsmr_1430"><p>提取最右侧1 </p><ul class="list _bullet" id="imlsmr_1431"><li class="list__item" id="imlsmr_1432"><p>N&amp;((~N)+1) N与((N取反)+1)</p></li></ul></li></ul></li></ul></section><section class="chapter"><h3 id="imlsmr_1433" data-toc="imlsmr_1433">排序</h3><ul class="list _bullet" id="imlsmr_1434"><li class="list__item" id="imlsmr_1435"><p>桶排序 </p><ul class="list _bullet" id="imlsmr_1436"><li class="list__item" id="imlsmr_1437"><p>数据状况强相关 -计数排序 </p><ul class="list _bullet" id="imlsmr_1438"><li class="list__item" id="imlsmr_1439"><p>设数组,累加</p></li></ul></li><li class="list__item" id="imlsmr_1440"><p>基数排序 </p><ul class="list _bullet" id="imlsmr_1441"><li class="list__item" id="imlsmr_1442"><p>非负十进制</p></li><li class="list__item" id="imlsmr_1443"><p>添0,入桶出桶</p></li><li class="list__item" id="imlsmr_1444"><p>权重逆着</p></li></ul></li></ul></li><li class="list__item" id="imlsmr_1445"><p>排序算法的稳定性 </p><ul class="list _bullet" id="imlsmr_1446"><li class="list__item" id="imlsmr_1447"><p>稳定性是指同样大小的样本再排序之后不会改变相对次序</p></li><li class="list__item" id="imlsmr_1448"><p>对基础类型来说,稳定性毫无意义</p></li><li class="list__item" id="imlsmr_1449"><p>对非基础类型来说,稳定性有重要意义</p></li><li class="list__item" id="imlsmr_1450"><p>有些算法可以实现成稳定的,而有些排序算法无论如何都实现不成稳定的</p></li><li class="list__item" id="imlsmr_1451"><p>有稳定性: -处理相等情况时的策略 </p><ul class="list _bullet" id="imlsmr_1452"><li class="list__item" id="imlsmr_1453"><p>冒泡排序</p></li><li class="list__item" id="imlsmr_1454"><p>插入排序</p></li><li class="list__item" id="imlsmr_1455"><p>归并排序</p></li><li class="list__item" id="imlsmr_1456"><p>桶排序 十分稳定 </p><ul class="list _bullet" id="imlsmr_1457"><li class="list__item" id="imlsmr_1458"><p>基数排序</p></li><li class="list__item" id="imlsmr_1459"><p>计数排序</p></li></ul></li></ul></li><li class="list__item" id="imlsmr_1460"><p>无稳定性: </p><ul class="list _bullet" id="imlsmr_1461"><li class="list__item" id="imlsmr_1462"><p>选择排序</p></li><li class="list__item" id="imlsmr_1463"><p>快排 </p><ul class="list _bullet" id="imlsmr_1464"><li class="list__item" id="imlsmr_1465"><p>partition过程必破坏稳定性</p></li></ul></li><li class="list__item" id="imlsmr_1466"><p>堆排</p></li></ul></li></ul></li><li class="list__item" id="imlsmr_1467"><p>序算法总结</p></li></ul><ol class="list _decimal" id="imlsmr_1468" type="1"><li class="list__item" id="imlsmr_1469"><p>不基于比较的排序,对样本数据有严格的要求,不易改写</p></li><li class="list__item" id="imlsmr_1470"><p>基于比较的排序,只要规定好两个样本怎么比大小就可以直接复用</p></li><li class="list__item" id="imlsmr_1471"><p>基于比较的排序,时间复杂度的极限是O(NlogN)</p></li><li class="list__item" id="imlsmr_1472"><p>时间复杂度O(NlogN),额外空间复杂度低于O(N),且稳定的基于比较的排序是不存在的</p></li><li class="list__item" id="imlsmr_1473"><p>为了绝对的速度选快排,为了省空间选堆排,为了稳定选归并</p></li><li class="list__item" id="imlsmr_1474"><p>小规模用常数项小的排序,例如插入排序,大规模用调度优秀的排序,如快排</p></li></ol><ul class="list _bullet" id="imlsmr_1475"><li class="list__item" id="imlsmr_1476"><p>常见的坑 </p><ol class="list _decimal" id="imlsmr_1477" type="1"><li class="list__item" id="imlsmr_1478"><p>归并排序的额外空间复杂度可以变成O(1),&quot;归并排序 内部缓存法&quot;,但是将变得不再稳定 -&gt;直接堆排</p></li><li class="list__item" id="imlsmr_1479"><p>&quot;原地归并排序&quot;是垃圾帖,会让时间复杂度变成O(N^2) -&gt;插入排序</p></li><li class="list__item" id="imlsmr_1480"><p>快排稳定性改进,&quot;01 stable sort&quot;,但是会对样本数据要求更多 -&gt;桶排序</p></li><li class="list__item" id="imlsmr_1481"><p>在整数数组中,请把奇数放在数组左边,偶数放在数组右边,要求所有奇数之间,偶数之间的原始相对次序不变 时间复杂度做到O(N).空间复杂度做到O(1)</p></li></ol></li></ul><div class="table-wrapper"><table class="wide" id="imlsmr_1482"><thead><tr class="ijRowHead" id="imlsmr_1483"><th id="imlsmr_1484"><p>排序方法</p></th><th id="imlsmr_1485"><p>时间复杂度(平均)</p></th><th id="imlsmr_1486"><p>时间复杂度(最坏)</p></th><th id="imlsmr_1487"><p>时间复杂度(最好)</p></th><th id="imlsmr_1488"><p>空间复杂度</p></th><th id="imlsmr_1489"><p>稳定性</p></th><th id="imlsmr_1490"><p>复杂性</p></th></tr></thead><tbody><tr id="imlsmr_1491"><td id="imlsmr_1492"><p>直接插入排序</p></td><td id="imlsmr_1493"><p>O(n2)</p></td><td id="imlsmr_1494"><p>O(n2)</p></td><td id="imlsmr_1495"><p>O(n)</p></td><td id="imlsmr_1496"><p>O(1)</p></td><td id="imlsmr_1497"><p>稳定</p></td><td id="imlsmr_1498"><p>简单</p></td></tr><tr id="imlsmr_1499"><td id="imlsmr_1500"><p>希尔排序</p></td><td id="imlsmr_1501"><p>O(nlog2n)</p></td><td id="imlsmr_1502"><p>O(n2)</p></td><td id="imlsmr_1503"><p>O(n1.3)</p></td><td id="imlsmr_1504"><p>O(1)</p></td><td id="imlsmr_1505"><p>不稳定</p></td><td id="imlsmr_1506"><p>较复杂</p></td></tr><tr id="imlsmr_1507"><td id="imlsmr_1508"><p>直接选择排序</p></td><td id="imlsmr_1509"><p>O(n2)</p></td><td id="imlsmr_1510"><p>O(n2)</p></td><td id="imlsmr_1511"><p>O(n2)</p></td><td id="imlsmr_1512"><p>O(1)</p></td><td id="imlsmr_1513"><p>不稳定</p></td><td id="imlsmr_1514"><p>简单</p></td></tr><tr id="imlsmr_1515"><td id="imlsmr_1516"><p>堆排序</p></td><td id="imlsmr_1517"><p>O(nlog2n)</p></td><td id="imlsmr_1518"><p>O(nlog2n)</p></td><td id="imlsmr_1519"><p>O(nlog2n)</p></td><td id="imlsmr_1520"><p>O(1)</p></td><td id="imlsmr_1521"><p>不稳定</p></td><td id="imlsmr_1522"><p>较复杂</p></td></tr><tr id="imlsmr_1523"><td id="imlsmr_1524"><p>冒泡排序</p></td><td id="imlsmr_1525"><p>O(n2)</p></td><td id="imlsmr_1526"><p>O(n2)</p></td><td id="imlsmr_1527"><p>O(n)</p></td><td id="imlsmr_1528"><p>O(1)</p></td><td id="imlsmr_1529"><p>稳定</p></td><td id="imlsmr_1530"><p>简单</p></td></tr><tr id="imlsmr_1531"><td id="imlsmr_1532"><p>快速排序</p></td><td id="imlsmr_1533"><p>O(nlog2n)</p></td><td id="imlsmr_1534"><p>O(n2)</p></td><td id="imlsmr_1535"><p>O(nlog2n)</p></td><td id="imlsmr_1536"><p>O(nlog2n)</p></td><td id="imlsmr_1537"><p>不稳定</p></td><td id="imlsmr_1538"><p>较复杂</p></td></tr><tr id="imlsmr_1539"><td id="imlsmr_1540"><p>归并排序</p></td><td id="imlsmr_1541"><p>O(nlog2n)</p></td><td id="imlsmr_1542"><p>O(nlog2n)</p></td><td id="imlsmr_1543"><p>O(nlog2n)</p></td><td id="imlsmr_1544"><p>O(n)</p></td><td id="imlsmr_1545"><p>稳定</p></td><td id="imlsmr_1546"><p>较复杂</p></td></tr><tr id="imlsmr_1547"><td id="imlsmr_1548"><p>基数排序</p></td><td id="imlsmr_1549"><p>O(d(n+r))</p></td><td id="imlsmr_1550"><p>O(d(n+r))</p></td><td id="imlsmr_1551"><p>O(d(n+r))</p></td><td id="imlsmr_1552"><p>O(n+r)</p></td><td id="imlsmr_1553"><p>稳定</p></td><td id="imlsmr_1554"><p>较复杂</p></td></tr></tbody></table></div></section></section><section class="chapter"><h2 id="imlsmr_1555" data-toc="imlsmr_1555">数据结构</h2><section class="chapter"><h3 id="imlsmr_1556" data-toc="imlsmr_1556">链表</h3><ul class="list _bullet" id="imlsmr_1557"><li class="list__item" id="imlsmr_1558"><p>反转链表,定义pre,next避免循环链表</p></li><li class="list__item" id="imlsmr_1559"><p>笔试 ,不用太在乎空间复杂度,一切为了时间复杂度</p></li><li class="list__item" id="imlsmr_1560"><p>面试,时间复杂度依然第一位,但一定要找到空间最省的方法</p></li></ul><section class="chapter"><h4 id="imlsmr_1561" data-toc="imlsmr_1561">快慢指针</h4><p id="imlsmr_1562">1.输入链表头节点,奇数长度返回中点,偶数长度返回上中点 2.输入链表头节点,奇数长度返回中点,偶数长度返回下中点 3.输入链表头节点,奇数长度返回中点前一个,偶数长度返回上中点前一个 4.输入链表头节点,奇数长度返回中点前一个,偶数长度返回下中点前一个 - 边界问题 - 笔试直接arraylist 5. 判断回文链表 - 笔试 -&gt;压栈<br> - 快慢指针 - 找中点,后半部分压栈,直到栈空,与前面节点顺序比较 - 不用容器 - 中点指向空,后半链表反着指,从两端往中间遍历,直到null - 最后要调回来 6. 将单向链表按某值划分成左边小中间相等右边大的形式 1. 把链表放入数组里,在数组上做partition(笔试用) 2. 分成小中大三个部分,再把各个部分之间串起来(面试用) -&gt;6个变量,O(N) - <a href="https://github.com/Anhlaidh/Coding/blob/master/src/main/java/Interview/Left/Test/LinkedList/ListPartition.java" id="imlsmr_1564" data-external="true" rel="noopener noreferrer">代码</a> 7. 一种特殊的单链表类描述如下 ```java</p><div class="code-block" data-lang="none">    class Node {
    int value;
    Node next;
    Node rand;
    Node(int val){value = val;}
    }
    ```
- rand指针是单链表结构中新增的指针,rand可能指向链表中任意一个节点,也可能指向null
给定一个由Node节点类型组成的无环单链表的头节点head,请实现一个函数完成这个链表的复制,并返回新的链表的头节点
    - 要求时间复杂度O(N)
    - 要求额外空间复杂度O(1)
1. Hash表&lt;Node,Node&gt; 顺着比对装一遍,再遍历,用cur和get(cur)来进行复制
2. 构造一个对应关系,例如1'在1后面2'在2后面,3'在3后面,找random找到老节点的random再next
    最后再在next方向分离出来
</div><ol class="list _decimal" id="imlsmr_1566" type="1" start="8"><li class="list__item" id="imlsmr_1567"><p>给定两个可能有环也可能无环的单链表,头节点head1和head2,请实现一个函数,如果两个链表相交,请返回相交的第一个节点,如果不相交,返回null </p><ul class="list _bullet" id="imlsmr_1568"><li class="list__item" id="imlsmr_1569"><p>要求:如果两个长度之和为N,时间复杂度请达到O(N),额外空间复杂度达到O(1)</p></li></ul></li></ol><ul class="list _bullet" id="imlsmr_1570"><li class="list__item" id="imlsmr_1571"><p>判定有无环,快慢指针,第一次相遇后,慢指针不动,快指针回原点,然后一起一次移动1个,下次相遇则是入环点 a. 给一个链表,返回入环的节点 b. 两个无环链表相交,返回第一个相交的节点 c. 两个有环链表,找到第一个相交的节点</p></li></ul><ol class="list _decimal" id="imlsmr_1572" type="1" start="9"><li class="list__item" id="imlsmr_1573"><p>能不能不给单链表头节点,只给删除的节点,就能做到在链表里删掉 </p><ul class="list _bullet" id="imlsmr_1574"><li class="list__item" id="imlsmr_1575"><p>借尸还魂,复制下一个节点的值,子节点指向下下个 a. 只替代了内容 b. 很大局限 c. 抖机灵 d. 无法删除最后一个节点</p></li><li class="list__item" id="imlsmr_1576"><p>不行,很大问题,以上问题,必须要给头节点</p></li></ul></li></ol></section></section><section class="chapter"><h3 id="imlsmr_1577" data-toc="imlsmr_1577">栈</h3><ul class="list _bullet" id="imlsmr_1578"><li class="list__item" id="imlsmr_1579"><p>要求可以立即返回最小值,且pop,push,getMin为O(1) </p><ul class="list _bullet" id="imlsmr_1580"><li class="list__item" id="imlsmr_1581"><p>单调栈(同步弹出省时间费空间) </p><ul class="list _bullet" id="imlsmr_1582"><li class="list__item" id="imlsmr_1583"><p>两个栈,一个栈为普通栈</p></li><li class="list__item" id="imlsmr_1584"><p>另一个为单调栈,普通栈压入的时候单调栈压数,小则放,大则放之前最小的</p></li><li class="list__item" id="imlsmr_1585"><p>可以同步大小</p></li></ul></li><li class="list__item" id="imlsmr_1586"><p>单调栈不同步压入(费时间省空间) </p><ul class="list _bullet" id="imlsmr_1587"><li class="list__item" id="imlsmr_1588"><p>判断当前两个栈顶是否一样</p></li></ul></li></ul></li><li class="list__item" id="imlsmr_1589"><p>用栈拼队列 </p><ul class="list _bullet" id="imlsmr_1590"><li class="list__item" id="imlsmr_1591"><p>两个栈 </p><ul class="list _bullet" id="imlsmr_1592"><li class="list__item" id="imlsmr_1593"><p>一个push,一个pop</p></li><li class="list__item" id="imlsmr_1594"><p>pop的时候倒过来再输出 </p><ul class="list _bullet" id="imlsmr_1595"><li class="list__item" id="imlsmr_1596"><p>pop栈为空的时候才可输出</p></li><li class="list__item" id="imlsmr_1597"><p>push一次性倒完</p></li></ul></li></ul></li></ul></li></ul></section><section class="chapter"><h3 id="imlsmr_1598" data-toc="imlsmr_1598">队列</h3><ul class="list _bullet" id="imlsmr_1599"><li class="list__item" id="imlsmr_1600"><p>用队列拼栈 </p><ul class="list _bullet" id="imlsmr_1601"><li class="list__item" id="imlsmr_1602"><p>分两个队列,data,help </p><ul class="list _bullet" id="imlsmr_1603"><li class="list__item" id="imlsmr_1604"><p>取的时候把data元素扔到help中,剩一个,输出</p></li><li class="list__item" id="imlsmr_1605"><p>然后help为data,data为help</p></li></ul></li></ul></li></ul></section><section class="chapter"><h3 id="hashset-hashmap" data-toc="hashset-hashmap">HashSet&amp;HashMap</h3><div class="code-block" data-lang="none">- 增删改查均为O(1)
- Integer等大类型在HashMap,HashSet中是按值传递
</div></section><section class="chapter"><h3 id="imlsmr_1607" data-toc="imlsmr_1607">有序表</h3><ul class="list _bullet" id="imlsmr_1608"><li class="list__item" id="imlsmr_1609"><p>TreeMap </p><ul class="list _bullet" id="imlsmr_1610"><li class="list__item" id="imlsmr_1611"><p>firstKey() 最小的</p></li><li class="list__item" id="imlsmr_1612"><p>lastKey() 最大的</p></li><li class="list__item" id="imlsmr_1613"><p>离xx最近且小于的 floorKey(xx)</p></li><li class="list__item" id="imlsmr_1614"><p>离xx最近且大于的 ceilingKey(xx)</p></li><li class="list__item" id="imlsmr_1615"><p>O(logN)</p></li></ul></li><li class="list__item" id="imlsmr_1616"><p>AVl</p></li><li class="list__item" id="imlsmr_1617"><p>红黑树</p></li><li class="list__item" id="imlsmr_1618"><p>跳表</p></li></ul></section><section class="chapter"><h3 id="imlsmr_1619" data-toc="imlsmr_1619">堆</h3><ul class="list _bullet" id="imlsmr_1620"><li class="list__item" id="imlsmr_1621"><p>结构上:完全二叉树 </p><ul class="list _bullet" id="imlsmr_1622"><li class="list__item" id="imlsmr_1623"><p>0开始 </p><ul class="list _bullet" id="imlsmr_1624"><li class="list__item" id="imlsmr_1625"><p>i的左子节点 2*i+1</p></li><li class="list__item" id="imlsmr_1626"><p>i的右子节点 2*i+2</p></li><li class="list__item" id="imlsmr_1627"><p>父节点(i-1)/2</p></li></ul></li><li class="list__item" id="imlsmr_1628"><p>1开始 </p><ul class="list _bullet" id="imlsmr_1629"><li class="list__item" id="imlsmr_1630"><p>i的左孩子 2*i</p></li></ul></li><li class="list__item" id="imlsmr_1631"><p>小根堆 </p><ul class="list _bullet" id="imlsmr_1632"><li class="list__item" id="imlsmr_1633"><p>父节点是最小的</p></li></ul></li><li class="list__item" id="imlsmr_1634"><p>均不是则不是堆</p></li></ul></li><li class="list__item" id="imlsmr_1635"><p><a href="https://github.com/Anhlaidh/Coding/blob/master/src/main/java/Interview/Left/Heap/HeapSort.java" id="imlsmr_1636" data-external="true" rel="noopener noreferrer">堆排序</a></p><ul class="list _bullet" id="imlsmr_1637"><li class="list__item" id="imlsmr_1638"><p>有关题目 </p><ul class="list _bullet" id="imlsmr_1639"><li class="list__item" id="imlsmr_1640"><p>几乎有序的数组排序,每个数去往的位置不超过k </p><ul class="list _bullet" id="imlsmr_1641"><li class="list__item" id="imlsmr_1642"><p>生成小根堆</p></li><li class="list__item" id="imlsmr_1643"><p>前k+1放入小根堆</p></li><li class="list__item" id="imlsmr_1644"><p>当前最小的可能性</p></li></ul></li></ul></li></ul></li><li class="list__item" id="imlsmr_1645"><p>PriorityQueue </p><ul class="list _bullet" id="imlsmr_1646"><li class="list__item" id="imlsmr_1647"><p>小根堆</p></li><li class="list__item" id="imlsmr_1648"><p>poll方法,由小到大弹出</p></li></ul></li></ul></section><section class="chapter"><h3 id="imlsmr_1649" data-toc="imlsmr_1649">二叉树</h3><ul class="list _bullet" id="imlsmr_1650"><li class="list__item" id="imlsmr_1651"><p>先序</p></li><li class="list__item" id="imlsmr_1652"><p>中序</p></li><li class="list__item" id="imlsmr_1653"><p>后序</p></li></ul><section class="chapter"><h4 id="imlsmr_1654" data-toc="imlsmr_1654">递归序</h4><ul class="list _bullet" id="imlsmr_1655"><li class="list__item" id="imlsmr_1656"><p>递归转迭代 </p><ul class="list _bullet" id="imlsmr_1657"><li class="list__item" id="imlsmr_1658"><p>压栈 </p><ul class="list _bullet" id="imlsmr_1659"><li class="list__item" id="imlsmr_1660"><p>头右左 </p><ol class="list _decimal" id="imlsmr_1661" type="1"><li class="list__item" id="imlsmr_1662"><p>弹</p></li><li class="list__item" id="imlsmr_1663"><p>如果有左,压入左</p></li><li class="list__item" id="imlsmr_1664"><p>如果有右,压入右</p></li></ol></li><li class="list__item" id="imlsmr_1665"><p>左右节点反着压</p></li><li class="list__item" id="imlsmr_1666"><p>输出压栈</p></li></ul></li></ul></li></ul></section><section class="chapter"><h4 id="imlsmr_1667" data-toc="imlsmr_1667">序列化反序列化</h4><ul class="list _bullet" id="imlsmr_1668"><li class="list__item" id="imlsmr_1669"><p>留null</p></li></ul></section><section class="chapter"><h4 id="imlsmr_1670" data-toc="imlsmr_1670">题目</h4><ul class="list _bullet" id="imlsmr_1671"><li class="list__item" id="imlsmr_1672"><p>打印二叉树</p></li><li class="list__item" id="imlsmr_1673"><p>后继节点 </p><ul class="list _bullet" id="imlsmr_1674"><li class="list__item" id="imlsmr_1675"><p>一棵二叉树,在中序遍历的序列中一个节点的下一个节点是谁,就是后继节点 </p><ul class="list _bullet" id="imlsmr_1676"><li class="list__item" id="imlsmr_1677"><p>找结构规律</p></li></ul></li><li class="list__item" id="imlsmr_1678"><p>凹凸折痕</p></li></ul></li></ul></section><section class="chapter"><h4 id="imlsmr_1679" data-toc="imlsmr_1679">二叉树的递归套路***</h4><ul class="list _bullet" id="imlsmr_1680"><li class="list__item" id="imlsmr_1681"><p>可以解决面试中绝大多数的二叉树问题,尤其树形dp</p></li><li class="list__item" id="imlsmr_1682"><p>本质是利用递归遍历二叉树的便利性</p></li></ul><section class="chapter"><h5 id="imlsmr_1683" data-toc="imlsmr_1683">规则</h5><ol class="list _decimal" id="imlsmr_1684" type="1"><li class="list__item" id="imlsmr_1685"><p>假设以X节点位头,可以向X左树和X右树要任何信息</p></li><li class="list__item" id="imlsmr_1686"><p>在上一步的假设下,讨论以X为头节点的树,得到答案的可能性(最重要)</p></li><li class="list__item" id="imlsmr_1687"><p>列出所有可能性后,确定到底需要向左树和右树要什么样的信息</p></li><li class="list__item" id="imlsmr_1688"><p>把左树信息和右树信息求全集,就是任何一棵子树都需要返回的信息S</p></li><li class="list__item" id="imlsmr_1689"><p>递归函数都返回S,每一棵子树都这么要求</p></li><li class="list__item" id="imlsmr_1690"><p>写代码,在写代码中考虑如何把左树的信息和右树的信息整合出整棵树的信息</p></li></ol></section><section class="chapter"><h5 id="imlsmr_1691" data-toc="imlsmr_1691">题目</h5><ol class="list _decimal" id="imlsmr_1692" type="1"><li class="list__item" id="imlsmr_1693"><p><a href="https://github.com/Anhlaidh/Coding/blob/master/src/main/java/Interview/Left/Tree/isBalance.java" id="imlsmr_1694" data-external="true" rel="noopener noreferrer">给定一棵二叉树的头节点位head,返回这颗二叉树是不是平衡二叉树</a></p></li><li class="list__item" id="imlsmr_1695"><p>给定一棵二叉树的头节点head,任何两个节点之家你都存在距离,返回整棵二叉树的最大距离</p></li><li class="list__item" id="imlsmr_1696"><p>给定一棵二叉树的头节点head,返回这颗树中最大的二叉搜索子树的头节点数</p></li><li class="list__item" id="imlsmr_1697"><p>派对的最大快乐值,多叉树 </p><ul class="list _bullet" id="imlsmr_1698"><li class="list__item" id="imlsmr_1699"><p>这个公司要开party,决定哪些员工来,哪些员工不来 </p><ol class="list _decimal" id="imlsmr_1700" type="1"><li class="list__item" id="imlsmr_1701"><p>如果某个员工来了,那么这个员工的所有直接下级都不能来</p></li><li class="list__item" id="imlsmr_1702"><p>派对的整体快乐值是所有到场员工的快乐值的累加</p></li><li class="list__item" id="imlsmr_1703"><p>你的目标是让派对的快乐值尽量大</p></li><li class="list__item" id="imlsmr_1704"><p>给定一棵多叉树的头节点boss,返回派对的最大快乐值</p></li></ol></li></ul></li><li class="list__item" id="imlsmr_1705"><p><a href="https://github.com/Anhlaidh/Coding/blob/master/src/main/java/Interview/Left/Tree/isCBT.java" id="imlsmr_1706" data-external="true" rel="noopener noreferrer">给定一个二叉树头,判断是否是完全二叉树</a></p></li><li class="list__item" id="imlsmr_1707"><p>给定一棵二叉树的头节点head,和另外两个节点a和b,返回a和b的最低公共祖先 </p><ul class="list _bullet" id="imlsmr_1708"><li class="list__item" id="imlsmr_1709"><p>hashset做 巨简单 <code class="code" id="imlsmr_1710">//TODO</code></p></li><li class="list__item" id="imlsmr_1711"><p><a href="https://github.com/Anhlaidh/Coding/blob/master/src/main/java/Interview/Left/Tree/Code07_lowestAncestor.java" id="imlsmr_1712" data-external="true" rel="noopener noreferrer">递归</a> 巨难</p></li></ul></li></ol></section></section></section><section class="chapter"><h3 id="imlsmr_1713" data-toc="imlsmr_1713">前缀树</h3><ul class="list _bullet" id="imlsmr_1714"><li class="list__item" id="imlsmr_1715"><p>单个字符串中,字符从前到后的加到一棵多叉树上</p></li><li class="list__item" id="imlsmr_1716"><p>字符放在路上,节点上又专属的数据项(常见的是pass和end值)</p></li><li class="list__item" id="imlsmr_1717"><p>所有样本都这样添加,如果没有就新建,如果有路就复用</p></li><li class="list__item" id="imlsmr_1718"><p>沿途节点的pass值增加1,每个字符串结束时的节点end增加1</p></li></ul><p id="imlsmr_1719">可以完成前缀相关的查询</p></section><section class="chapter"><h3 id="imlsmr_1720" data-toc="imlsmr_1720">图</h3><ul class="list _bullet" id="imlsmr_1721"><li class="list__item" id="imlsmr_1722"><p>BFS <a href="https://github.com/Anhlaidh/Coding/blob/master/src/main/java/Interview/Left/graph/BFS.java" id="imlsmr_1723" data-external="true" rel="noopener noreferrer">宽度优先遍历</a></p></li><li class="list__item" id="imlsmr_1724"><p>DFS <a href="https://github.com/Anhlaidh/Coding/blob/master/src/main/java/Interview/Left/graph/DFS.java" id="imlsmr_1725" data-external="true" rel="noopener noreferrer">深度优先遍历</a></p></li><li class="list__item" id="imlsmr_1726"><p><span id="imlsmr_1727">题目先变换成自己掌握的结构</span>)</p></li><li class="list__item" id="imlsmr_1728"><p>拓扑排序 -&gt; 依赖问题</p></li><li class="list__item" id="imlsmr_1729"><p>最小生成树 </p><ul class="list _bullet" id="imlsmr_1730"><li class="list__item" id="imlsmr_1731"><p>kruskal(用最小边找所有点) </p><ul class="list _bullet" id="imlsmr_1732"><li class="list__item" id="imlsmr_1733"><p>由小到大union操作,直到包含所有元素</p></li><li class="list__item" id="imlsmr_1734"><p>并查集</p></li></ul></li><li class="list__item" id="imlsmr_1735"><p>prime(用出发点找最小边循环解锁所有点) </p><ul class="list _bullet" id="imlsmr_1736"><li class="list__item" id="imlsmr_1737"><p>点边点边解锁,点集,边集(由小到大,堆)</p></li></ul></li><li class="list__item" id="imlsmr_1738"><p>Dijkstra(给定出发点找到出发点通往其他所有点的最短路径) </p><ul class="list _bullet" id="imlsmr_1739"><li class="list__item" id="imlsmr_1740"><p>给定出发点 </p><ul class="list _bullet" id="imlsmr_1741"><li class="list__item" id="imlsmr_1742"><p>创建一个对出发点负责的表</p></li><li class="list__item" id="imlsmr_1743"><p>贪心</p></li><li class="list__item" id="imlsmr_1744"><p>表中依次解锁新可达边/更新最短距离,锁死已检索的边</p></li></ul></li><li class="list__item" id="imlsmr_1745"><p>找到图中这个点到所有节点的最小值</p></li><li class="list__item" id="imlsmr_1746"><p>TSP问题(商旅问题) 不同于Dijkstra </p><ul class="list _bullet" id="imlsmr_1747"><li class="list__item" id="imlsmr_1748"><p>出发回自己城市,经过所有城市且只有一次,求最小代价</p></li></ul></li><li class="list__item" id="imlsmr_1749"><p>优化 </p><ul class="list _bullet" id="imlsmr_1750"><li class="list__item" id="imlsmr_1751"><p>建表使用小根堆(自己写,系统不能改写时重排序) </p><ul class="list _bullet" id="imlsmr_1752"><li class="list__item" id="imlsmr_1753"><p>add, update,ignore</p></li></ul></li></ul></li></ul></li></ul></li></ul></section></section><section class="chapter"><h2 id="imlsmr_1754" data-toc="imlsmr_1754">递归</h2><ul class="list _bullet" id="imlsmr_1755"><li class="list__item" id="imlsmr_1756"><p id="imlsmr_1757">Master公式</p><ul class="list _bullet" id="imlsmr_1758"><li class="list__item" id="imlsmr_1759"><p>T(N) = aT(N/b)+O(N^d) </p><ul class="list _bullet" id="imlsmr_1760"><li class="list__item" id="imlsmr_1761"><p>子问题的规模是一致的(N/b)</p></li><li class="list__item" id="imlsmr_1762"><p>子问题调用了a次</p></li><li class="list__item" id="imlsmr_1763"><p>除了子问题调用之外,生下的复杂度为O(N^d)</p></li><li class="list__item" id="imlsmr_1764"><p>log(b)a&gt;d,O(N^log(b)a)</p></li><li class="list__item" id="imlsmr_1765"><p>log(b)a&lt;d,O(N^d)</p></li><li class="list__item" id="imlsmr_1766"><p>log(b)a==d,O(N^d(*logN))</p></li></ul></li></ul></li><li class="list__item" id="imlsmr_1767"><p id="imlsmr_1768">归并排序 思想</p><ul class="list _bullet" id="imlsmr_1769"><li class="list__item" id="imlsmr_1770"><p>左边数量多少个大,左边数量多少个小,右边数量多少个大,右边数量多少个小(用mergeSort改) </p><ul class="list _bullet" id="imlsmr_1771"><li class="list__item" id="imlsmr_1772"><p>在一个数组中,一个数左边比他小的数的总和,叫数的小和,所有数的小和累加起来,叫数组小和,求数组小和 </p><ul class="list _bullet" id="imlsmr_1773"><li class="list__item" id="imlsmr_1774"><p>加返回值,修改merge()</p></li></ul></li><li class="list__item" id="imlsmr_1775"><p>降序对 - 右边有多少个数比它小</p></li></ul></li></ul></li><li class="list__item" id="imlsmr_1776"><p id="imlsmr_1777">快排 思想</p><ul class="list _bullet" id="imlsmr_1778"><li class="list__item" id="imlsmr_1779"><p>指定num,将数组分为小于等于num的和大于num的两个区 </p><ul class="list _bullet" id="imlsmr_1780"><li class="list__item" id="imlsmr_1781"><p>设定小于等于区从-1开始,然后指针遍历数组直到越界 </p><ul class="list _bullet" id="imlsmr_1782"><li class="list__item" id="imlsmr_1783"><p>如果当前数字大于num则不动,cur指针+1</p></li><li class="list__item" id="imlsmr_1784"><p>如果当前数字小于等于num,cur指针的数于小于等于区指针的数互换,小于等于区指针++,cur指针++</p></li></ul></li></ul></li><li class="list__item" id="imlsmr_1785"><p>给定num分成三块,小于区,等于区,大于区 </p><ul class="list _bullet" id="imlsmr_1786"><li class="list__item" id="imlsmr_1787"><p>分三个区,小于区,等于区,大于区,i跟大于区边界撞上的时候停止 </p><ul class="list _bullet" id="imlsmr_1788"><li class="list__item" id="imlsmr_1789"><p>arr[i]==num,i++</p></li><li class="list__item" id="imlsmr_1790"><p>arr[i]&lt;num,arr[i]与小于区的右一个交换(有等于的情况,与之前思路不同 ),小于区右扩,i++</p></li><li class="list__item" id="imlsmr_1791"><p>arr[i]&gt;num,arr[i]与大于区做一个交换,大于区左扩,i不变</p></li></ul></li></ul></li><li class="list__item" id="imlsmr_1792"><p>荷兰国旗问题 </p><ul class="list _bullet" id="imlsmr_1793"><li class="list__item" id="imlsmr_1794"><p>以arr[R]划分</p></li></ul></li><li class="list__item" id="imlsmr_1795"><p>快排1.0 O(n) </p><ul class="list _bullet" id="imlsmr_1796"><li class="list__item" id="imlsmr_1797"><p>mid放中间,左右两侧递归</p></li><li class="list__item" id="imlsmr_1798"><p>有序的时候效率最低</p></li></ul></li><li class="list__item" id="imlsmr_1799"><p>快排2.0 O(n) </p><ul class="list _bullet" id="imlsmr_1800"><li class="list__item" id="imlsmr_1801"><p>荷兰国旗问题,分为小于区,等于区,大于区,一次可以搞定一批等于的mid</p></li><li class="list__item" id="imlsmr_1802"><p>有序的时候效率最低</p></li></ul></li><li class="list__item" id="imlsmr_1803"><p>快排3.0随机快排 O(N logN)-&gt;概率累加期望 额外空间复杂度O(logN) </p><ul class="list _bullet" id="imlsmr_1804"><li class="list__item" id="imlsmr_1805"><p>随机找一个值跟arr[R]交换,然后执行2.0</p></li></ul></li></ul></li></ul></section><section class="chapter"><h2 id="imlsmr_1806" data-toc="imlsmr_1806">贪心算法</h2><ol class="list _decimal" id="imlsmr_1807" type="1"><li class="list__item" id="imlsmr_1808"><p>最自然智慧的算法</p></li><li class="list__item" id="imlsmr_1809"><p>用一种局部最功利的标准,总是做出在当前来看最好的选择</p></li><li class="list__item" id="imlsmr_1810"><p>难点在于证明局部最功利的标准可以得到全局最优解</p></li><li class="list__item" id="imlsmr_1811"><p>对于贪心算法的学习主要以增加阅历为主</p></li></ol><section class="chapter"><h3 id="imlsmr_1812" data-toc="imlsmr_1812">并查集</h3><ol class="list _decimal" id="imlsmr_1813" type="1"><li class="list__item" id="imlsmr_1814"><p>有若干个样本a,b,c,d类型设为V</p></li><li class="list__item" id="imlsmr_1815"><p>在并查集中一开始认为每个样本都在单独的集合里</p></li><li class="list__item" id="imlsmr_1816"><p>用户可以在任何时候调用如下两个方法: </p><ul class="list _bullet" id="imlsmr_1817"><li class="list__item" id="imlsmr_1818"><p>boolean isSameSet(V x,V y)查询到样本x和样本y是否属于同一个集合</p><br><p> void union(V x, V y)把x和y各自所在的样本合并成一个集合</p></li><li class="list__item" id="imlsmr_1820"><p>isSameSet和union方法代价越低越好</p></li></ul></li></ol></section><section class="chapter"><h3 id="imlsmr_1821" data-toc="imlsmr_1821">过程</h3><ol class="list _decimal" id="imlsmr_1822" type="1"><li class="list__item" id="imlsmr_1823"><p>实现一个不依靠贪心策略的解法X,可以用最暴力的尝试</p></li><li class="list__item" id="imlsmr_1824"><p>脑补出贪心策略A,策略B,策略C</p></li><li class="list__item" id="imlsmr_1825"><p>解法X和对数器,用实验方式得知哪个最正确</p></li><li class="list__item" id="imlsmr_1826"><p>不要去纠结证明</p></li></ol></section><section class="chapter"><h3 id="imlsmr_1827" data-toc="imlsmr_1827">题目</h3><ol class="list _decimal" id="imlsmr_1828" type="1"><li class="list__item" id="imlsmr_1829"><p>给定一个由字符串组成的数组strs必须把所有的字符串拼接起来 返回所有可能的拼接结果中,字典序最小的结果 </p><ul class="list _bullet" id="imlsmr_1830"><li class="list__item" id="imlsmr_1831"><p>暴力,全排列,深度优先</p></li></ul><ol class="list _decimal" id="imlsmr_1832" type="1"><li class="list__item" id="imlsmr_1833"><p>长度一样看成一个26进制的数 '*'表示居民点,可以 放灯,需要点亮,如果灯放在i位置,可 以让i-1,i和i+1三个位置被点亮,返回如果点亮str中所有需要点亮的位置,至少需要几盏灯</p></li></ol></li><li class="list__item" id="imlsmr_1834"><p>哈夫曼树 </p><ul class="list _bullet" id="imlsmr_1835"><li class="list__item" id="imlsmr_1836"><p>去平均</p></li><li class="list__item" id="imlsmr_1837"><p>小根堆,取两个最小的,相加,放回去,且加入节点,从下向上形成哈夫曼树</p></li><li class="list__item" id="imlsmr_1838"><p>代价为非叶子节点的和</p></li><li class="list__item" id="imlsmr_1839"><p><a href="https://github.com/Anhlaidh/Coding/blob/master/src/main/java/Interview/Left/greedy/lessMoney.java" id="imlsmr_1840" data-external="true" rel="noopener noreferrer">最小花费</a></p><ul class="list _bullet" id="imlsmr_1841"><li class="list__item" id="imlsmr_1842"><figure id="imlsmr_1843"><img alt="Less gold" src="images/lessGold.png" title="Less gold" width="1252" height="524"></figure></li></ul></li></ul></li><li class="list__item" id="imlsmr_1844"></li></ol></section></section><section class="chapter"><h2 id="imlsmr_1845" data-toc="imlsmr_1845">暴力递归</h2><p id="imlsmr_1846">暴力递归就是尝试</p><ol class="list _decimal" id="imlsmr_1847" type="1"><li class="list__item" id="imlsmr_1848"><p>把问题转化为规模缩小了的同类问题的子问题</p></li><li class="list__item" id="imlsmr_1849"><p>有明确的不需要继续进行递归的条件(base case)</p></li><li class="list__item" id="imlsmr_1850"><p>有当得到了子问题的结果之后的决策过程</p></li><li class="list__item" id="imlsmr_1851"><p>不记录每一个子问题的解</p></li></ol><ul class="list _bullet" id="imlsmr_1852"><li class="list__item" id="imlsmr_1853"><p>大量重复计算</p></li></ul><section class="chapter"><h3 id="imlsmr_1854" data-toc="imlsmr_1854">题目</h3><ol class="list _decimal" id="imlsmr_1855" type="1"><li class="list__item" id="imlsmr_1856"><p><a href="https://github.com/Anhlaidh/Coding/blob/master/src/main/java/Interview/Left/ViolentRecursion/hanoi.java" id="imlsmr_1857" data-external="true" rel="noopener noreferrer">汉诺塔</a></p><ul class="list _bullet" id="imlsmr_1858"><li class="list__item" id="imlsmr_1859"><p>移动步数 (2^N)-1</p></li></ul></li><li class="list__item" id="imlsmr_1860"><p><a href="https://github.com/Anhlaidh/Coding/blob/master/src/main/java/Interview/Left/ViolentRecursion/hreverseStack.java" id="imlsmr_1861" data-external="true" rel="noopener noreferrer">给一个栈,逆序这个栈,不能申请额外数据结构,只能使用递归函数</a></p></li><li class="list__item" id="imlsmr_1862"><p>打印字符串字串/子序列 </p><ul class="list _bullet" id="imlsmr_1863"><li class="list__item" id="imlsmr_1864"><p>字串 </p><ul class="list _bullet" id="imlsmr_1865"><li class="list__item" id="imlsmr_1866"><p><a href="https://github.com/Anhlaidh/Coding/blob/master/src/main/java/Interview/Left/ViolentRecursion/AllPermutations.java" id="imlsmr_1867" data-external="true" rel="noopener noreferrer">全排列</a></p><ul class="list _bullet" id="imlsmr_1868"><li class="list__item" id="imlsmr_1869"><p>去重--&gt;容器set </p><ul class="list _bullet" id="imlsmr_1870"><li class="list__item" id="imlsmr_1871"><p>分支定界 -&gt;用set来登记,限制不必要的支路在源头杀死</p></li></ul></li></ul></li></ul></li><li class="list__item" id="imlsmr_1872"><p><a href="https://github.com/Anhlaidh/Coding/blob/master/src/main/java/Interview/Left/ViolentRecursion/subSequence.java" id="imlsmr_1873" data-external="true" rel="noopener noreferrer">子序列</a></p><ul class="list _bullet" id="imlsmr_1874"><li class="list__item" id="imlsmr_1875"><p>去重--&gt;容器用set</p></li><li class="list__item" id="imlsmr_1876"><p>子序列数量--&gt;动态规划</p></li></ul></li></ul></li></ol><section class="chapter"><h4 id="imlsmr_1877" data-toc="imlsmr_1877">往左往右尝试模型</h4><ul class="list _bullet" id="imlsmr_1878"><li class="list__item" id="imlsmr_1879"><p>规定1和A对应,2和B对应...那么一个数字字符串&quot;111&quot;会转换成 &quot;AAA&quot; &quot;AK&quot; &quot;KA&quot; </p><ul class="list _bullet" id="imlsmr_1880"><li class="list__item" id="imlsmr_1881"><p>问总共多少转化结果</p></li></ul></li><li class="list__item" id="imlsmr_1882"><p>博弈论 [从小往大分析] </p><ul class="list _bullet" id="imlsmr_1883"><li class="list__item" id="imlsmr_1884"><p>ab从最左或最右拿牌,目标面值最高,求胜利者的面值 </p><ul class="list _bullet" id="imlsmr_1885"><li class="list__item" id="imlsmr_1886"><p>双方玩家都不会在对方单独改变策略的情况下让对方得到收益</p></li></ul></li><li class="list__item" id="imlsmr_1887"><p>人过河 鱼吃人 人该什么时候过河 鱼吃掉人之后鱼会变成食物 鱼绝顶聪明 会决策 </p><ul class="list _bullet" id="imlsmr_1888"><li class="list__item" id="imlsmr_1889"><p>从小到大分析 </p><ul class="list _bullet" id="imlsmr_1890"><li class="list__item" id="imlsmr_1891"><p>一只鱼 -&gt;必吃</p></li><li class="list__item" id="imlsmr_1892"><p>两只鱼 -&gt; 不吃</p></li><li class="list__item" id="imlsmr_1893"><p>归纳-&gt;奇数不过河,偶数过河</p></li></ul></li></ul></li><li class="list__item" id="imlsmr_1894"><p>海盗分硬币 </p><ul class="list _bullet" id="imlsmr_1895"><li class="list__item" id="imlsmr_1896"><p>100个硬币,分给五个人,每个人提出方案,其他人投票是否赞成,赞成票超过一半方案则会被采纳,否则会被杀死 人性本恶 </p><ul class="list _bullet" id="imlsmr_1897"><li class="list__item" id="imlsmr_1898"><p>第一个人在自己不会死的情况下,提出对自己最优的方案,从小到大思考问题 </p><ol class="list _decimal" id="imlsmr_1899" type="1"><li class="list__item" id="imlsmr_1900"><p>E一个人 必然得到100个金币 [100]</p></li><li class="list__item" id="imlsmr_1901"><p>DE两个人 ,D必死 无论D如何决策,E投反对票,情况返回到1 [N,100]</p></li><li class="list__item" id="imlsmr_1902"><p>CDE三个人,因为C如果死掉,情况会变回2 所以无论C如何决策D都会同意 [100,0,0]</p></li><li class="list__item" id="imlsmr_1903"><p>BCDE四个人,如果B死了,情况会变回3,[100,0,0],所以给d,e分别1个 [98,0,1,1]</p></li><li class="list__item" id="imlsmr_1904"><p>ABCDE五个人,不会去拉拢B,[97,0,1,0,2]或者[97,0,1,2,0]</p></li></ol></li><li class="list__item" id="imlsmr_1905"><p>人性本善的模型 超过半数的模型 具体问题具体分析 都是从小往大分析</p></li></ul></li></ul></li><li class="list__item" id="imlsmr_1906"><p>欧拉信封 </p><ul class="list _bullet" id="imlsmr_1907"><li class="list__item" id="imlsmr_1908"><p>一个村里,每个人必须寄出一封信,不能寄给自己,每个人只能收到一封信,有多少种寄信的方式 </p><ol class="list _decimal" id="imlsmr_1909" type="1"><li class="list__item" id="imlsmr_1910"><p>1个人 0种</p></li><li class="list__item" id="imlsmr_1911"><p>2个人 1种</p></li><li class="list__item" id="imlsmr_1912"><p>3个人 ABC ACB 两种</p></li><li class="list__item" id="imlsmr_1913"><p>5个人 f(i) 输入多少人 返回可能性数量 </p><ul class="list _bullet" id="imlsmr_1914"><li class="list__item" id="imlsmr_1915"><p>假设B寄给E </p><ol class="list _decimal" id="imlsmr_1916" type="1"><li class="list__item" id="imlsmr_1917"><p>E回寄给B 情况会变成三个人的欧拉信封问题 f(3)</p></li><li class="list__item" id="imlsmr_1918"><p>E不寄给B </p><ul class="list _bullet" id="imlsmr_1919"><li class="list__item" id="imlsmr_1920"><p>E跟B会看成一个节点,从B入从E出 看成一个人 f(4)</p></li></ul></li></ol><ul class="list _bullet" id="imlsmr_1921"><li class="list__item" id="imlsmr_1922"><p>这种假设下 f(5) = f(3)+f(4)</p></li></ul></li><li class="list__item" id="imlsmr_1923"><p>有四种可能性 所以f(5) = 4(f(3)+f(4))</p></li></ul></li></ol></li></ul></li><li class="list__item" id="imlsmr_1924"><p><a href="https://github.com/algorithmzuo/algorithmbasic2020/blob/master/src/class11/Code09_NQueens.java" id="imlsmr_1925" data-external="true" rel="noopener noreferrer">N皇后</a></p><ul class="list _bullet" id="imlsmr_1926"><li class="list__item" id="imlsmr_1927"><p>尝试方法 已经无法优化 但是常数项可以优化</p></li><li class="list__item" id="imlsmr_1928"><p>N*N的棋盘上摆N个皇后 要求不同行不同列 不在一条斜线 </p><ol class="list _decimal" id="imlsmr_1929" type="1"><li class="list__item" id="imlsmr_1930"><p>1皇后 不成问题</p></li><li class="list__item" id="imlsmr_1931"><p>2皇后 0种</p></li><li class="list__item" id="imlsmr_1932"><p>3皇后 0种</p></li><li class="list__item" id="imlsmr_1933"><p>4皇后 4*4 2种</p></li></ol><ul class="list _bullet" id="imlsmr_1934"><li class="list__item" id="imlsmr_1935"><p>一行一行试 一行放一个皇后 ,挨个试,不行就回溯</p></li></ul></li><li class="list__item" id="imlsmr_1936"><p>常数项优化 -&gt; 位运算 非常有效</p></li></ul></li></ul></li></ul></section></section></section><section class="chapter"><h2 id="imlsmr_1937" data-toc="imlsmr_1937">动态规划</h2><ul class="list _bullet" id="imlsmr_1938"><li class="list__item" id="imlsmr_1939"><p>暴力递归中范围上的尝试模型 </p><ul class="list _bullet" id="imlsmr_1940"><li class="list__item" id="imlsmr_1941"><p>模型 拆子问题的组织方法</p></li></ul></li><li class="list__item" id="imlsmr_1942"><p>用缓存来减少重复计算</p></li><li class="list__item" id="imlsmr_1943"><p>只要可变参数是有限几个,只要能试出由可变参数代表的暴力递归,就能改成动态规划</p></li><li class="list__item" id="imlsmr_1944"><p>不是所有的暴力递归都能改成动态规划,所有的动态规划都来自于某一个暴力递归</p></li><li class="list__item" id="imlsmr_1945"><p>撞不上重复可能 没必要改成暴力递归</p></li></ul><section class="chapter"><h3 id="imlsmr_1946" data-toc="imlsmr_1946">四种尝试模型</h3><ol class="list _decimal" id="imlsmr_1947" type="1"><li class="list__item" id="imlsmr_1948"><p>从左往右的尝试模型 v </p><ul class="list _bullet" id="imlsmr_1949"><li class="list__item" id="imlsmr_1950"><p>背包问题</p></li><li class="list__item" id="imlsmr_1951"><p>数字转字符串</p></li><li class="list__item" id="imlsmr_1952"><p><a href="https://github.com/Anhlaidh/Coding/blob/master/src/main/java/Interview/Left/Dynamic/CostMoney.java" id="imlsmr_1953" data-external="true" rel="noopener noreferrer">钱数问题</a></p></li><li class="list__item" id="imlsmr_1954"><p>二维表 </p><ul class="list _bullet" id="imlsmr_1955"><li class="list__item" id="imlsmr_1956"><p><a href="https://github.com/Anhlaidh/Coding/blob/master/src/main/java/Interview/Left/Dynamic/SplitSumClosed.java" id="imlsmr_1957" data-external="true" rel="noopener noreferrer">将一个数组分成均匀的两部分</a></p></li></ul></li></ul></li><li class="list__item" id="imlsmr_1958"><p>范围上的尝试模型 v </p><ul class="list _bullet" id="imlsmr_1959"><li class="list__item" id="imlsmr_1960"><p>卡片 凑string</p></li><li class="list__item" id="imlsmr_1961"><p>最长重复子串 </p><ul class="list _bullet" id="imlsmr_1962"><li class="list__item" id="imlsmr_1963"><p>f(左右都变) f(左) f(右) 左右一致,2+f(左右)</p></li><li class="list__item" id="imlsmr_1964"><p>动态规划 -&gt; dp </p><ul class="list _bullet" id="imlsmr_1965"><li class="list__item" id="imlsmr_1966"><p>动态规划优化: dp[左]必大于dp[左下] 右同理,所以只需要比较左右,然后比较2+dp[左右]</p></li></ul></li></ul></li><li class="list__item" id="imlsmr_1967"><p>马走日</p></li></ul></li><li class="list__item" id="imlsmr_1968"><p>多样本位置全对应的尝试模型</p></li><li class="list__item" id="imlsmr_1969"><p>寻找业务限制的尝试模型</p></li></ol></section><section class="chapter"><h3 id="imlsmr_1970" data-toc="imlsmr_1970">如何找到某个问题的动态规划方式</h3><ol class="list _decimal" id="imlsmr_1971" type="1"><li class="list__item" id="imlsmr_1972"><p>设计暴力递归:重要原则+4种常见尝试模型 重点!</p></li><li class="list__item" id="imlsmr_1973"><p>分析有没有重复解:套路解决</p></li><li class="list__item" id="imlsmr_1974"><p>用记忆化搜索 -&gt; 严格表结构实现动态规划 套路解决</p></li><li class="list__item" id="imlsmr_1975"><p>看看能否继续优化 套路解决</p></li></ol></section><section class="chapter"><h3 id="imlsmr_1976" data-toc="imlsmr_1976">面试中设计暴力递归过程的过程</h3><ol class="list _decimal" id="imlsmr_1977" type="1"><li class="list__item" id="imlsmr_1978"><p>每一个可变参数的类型,一定不要比int类型更复杂</p></li><li class="list__item" id="imlsmr_1979"><p>原则1可以违反,让类型突破到一维线性结构,那必须是唯一可变参数</p></li><li class="list__item" id="imlsmr_1980"><p>如果发现原则1违反,但不违反原则2,只需要做到记忆化搜索即可</p></li><li class="list__item" id="imlsmr_1981"><p>可变参数个数,能少则少</p></li></ol></section><section class="chapter"><h3 id="imlsmr_1982" data-toc="imlsmr_1982">题目</h3><ol class="list _decimal" id="imlsmr_1983" type="1"><li class="list__item" id="imlsmr_1984"><p>题目一 </p><ul class="list _bullet" id="imlsmr_1985"><li class="list__item" id="imlsmr_1986"><p>假设有拍成一行的N个位置,记录为1-N ,N一定大于或者等于2,开始时机器人在其中的M位置上(M一定是1~N中的一个) </p><ul class="list _bullet" id="imlsmr_1987"><li class="list__item" id="imlsmr_1988"><p>如果机器人来到1位置,那么下一步只能往右来到2位置</p></li><li class="list__item" id="imlsmr_1989"><p>如果机器人来到N位置,那么下一步只能往左来到N-1位置</p></li><li class="list__item" id="imlsmr_1990"><p>如果机器人来到中间位置,那么下一步可以往左或者往右走</p></li><li class="list__item" id="imlsmr_1991"><p>规定机器人必须走K步,最终能来到P位置(P也是1~N中的一个)的方法有很多种</p></li><li class="list__item" id="imlsmr_1992"><p>给定四个参数 N(规模),M(初始位置),K(需要的步数),P(目标),返回方法数</p></li></ul></li></ul></li></ol></section></section><section class="chapter"><h2 id="imlsmr_1993" data-toc="imlsmr_1993">预处理</h2><section class="chapter"><h3 id="imlsmr_1994" data-toc="imlsmr_1994">前缀和求数组滚动窗口和</h3></section></section><section class="chapter"><h2 id="imlsmr_1995" data-toc="imlsmr_1995">问题范围和问题答案是否有线性规律</h2><ul class="list _bullet" id="imlsmr_1996"><li class="list__item" id="imlsmr_1997"><p>双端队列 </p><ul class="list _bullet" id="imlsmr_1998"><li class="list__item" id="imlsmr_1999"><p>最xx优先级队列</p></li><li class="list__item" id="imlsmr_2000"><p>滑动窗口问题</p></li></ul></li><li class="list__item" id="imlsmr_2001"><p>单调栈</p></li></ul></section><div class="last-modified">Last modified: 30 四月 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="jvm-1.html" class="navigation-links__prev">JVM</a><a href="java.html" class="navigation-links__next">Java-1</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b259/app.js"></script></body></html>